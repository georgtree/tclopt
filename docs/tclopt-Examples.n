'\"
'\" '\" Copyright (c) George Yashin
'\"
.TH "Examples" 3tcl 0\&.21 "tclopt" "Tcl wrapper for C optimization procedures"
.SH NAME
Examples - Commands in namespace Examples
.SH EXAMPLES
.PP
This section contains examples of usage of fitting procedures of the package\&.
List of availible examples:
.TP
\(bu
\fIFit to sum of sinusoidal functions\fP - "examples/sinfit\&.tcl" file
.TP
\(bu
\fIFind minimum of 2D Rozenbrock function with Differential Evolution algorithm\fP - "examples/diffEvolution_Rozenbrock\&.tcl" file
.SH "FIT TO SUM OF SINUSOIDAL FUNCTIONS"
.PP
First step is to import packages:
.PP
.RS 4n
.nf
package require tclopt
package require ticklecharts
set ::ticklecharts::theme "dark"
namespace import ::tcl::mathfunc::*
namespace import ::tclopt::*
.fi
.RE
.PP
Then we set seed for rand function with srand:
.PP
.RS 4n
.nf
srand 10
.fi
.RE
.PP
Define function for generating random number from min value to max value:
.PP
.RS 4n
.nf
proc randFloat {min max} {
    return [expr {rand()*($max-$min)+$min}]
}
.fi
.RE
.PP
As data for fit we generate 100 points with step 0\&.01 using next function:
.PP
.RS 4n
.nf
randFloat(0\&.9, 1\&.1) ⋅ (sin(1\&.5 ⋅ x) + sin(11 ⋅ x) + sin(6 ⋅ x))
.fi
.RE
.PP
Data generation code:
.PP
.RS 4n
.nf
for {set i 0} {$i<100} {incr i} {
    set xi [= {$i*0\&.01}]
    lappend x $xi
    lappend y [= {[randFloat 0\&.9 1\&.1]*(sin(1\&.5*$xi)+sin(11*$xi)+sin(6*$xi))}]
}
set pdata [dcreate x $x y $y]
.fi
.RE
.PP
Next we define function we want to minimize:
.PP
.RS 4n
.nf
proc sinfunc {xall pdata args} {
    set x [dget $pdata x]
    set y [dget $pdata y]
    foreach xVal $x yVal $y {
        set f [= {sin([@ $xall 0]*$xVal)+sin([@ $xall 1]*$xVal)+sin([@ $xall 2]*$xVal)}]
        lappend fvec [= {$yVal-$f}]
        lappend fval $f
    }
    return [dcreate fvec $fvec fval $fval]
}

.fi
.RE
.PP
On input we have pdata dictionary that contains x and y points for calculating residuals\&.
Residuals are calculated as such:
.PP
.RS 4n
.nf
fvec = y - (sin(p0 ⋅ x) + sin(p1 ⋅ x) + sin(p2 ⋅ x))
.fi
.RE
.PP
Also we save the function values to calculate the fitted data, and return dictionary containing both lists\&.
For \fI::tclopt::Mpfit::run\fP procedure we must provide the dictionary with fvec key\&.
.PP
We have 3 parameters, and we can make optimization faster if we provide resasonable limits to parameters values\&.
For that task we create \fI::tclopt::ParameterMpfit\fP objects and set boundaries for each parameter as \fI0,20\fP, and
then this list will be the input to \fI::tclopt::Mpfit\fP procedure)\&.
.PP
.RS 4n
.nf
set xInitial [list 3\&.0 8\&.0 1\&.0]
set par0 [ParameterMpfit new a [@ $xInitial 0] -lowlim 0 -uplim 20]
set par1 [ParameterMpfit new b [@ $xInitial 1] -lowlim 0 -uplim 20]
set par2 [ParameterMpfit new c [@ $xInitial 2] -lowlim 0 -uplim 20]
.fi
.RE
.PP
We define optimizer object \fI::tclopt::Mpfit\fP and added parameters objects to it:
.PP
.RS 4n
.nf
set optimizer [Mpfit new -funct sinfunc -m 100 -pdata $pdata]
$optimizer addPars $par0 $par1 $par2
.fi
.RE
.PP
We provide name of our function as an -funct argument, define the number of point -m 100 and data for
calculating residuals -pdata $pdata\&. Also, the important fact: in the order we add parameters to optimizer
object the parameters will be passed to minimizing function, and method \fI::tclopt::Mpfit::run\fP returns final
values list under key 'x' in the same order\&.
.PP
Now we are ready to call optimization routine with method \fI::tclopt::Mpfit::run\fP and collect the results:
.PP
.RS 4n
.nf
set result [$optimizer run]
set yinitial [dget [sinfunc $xInitial $pdata] fval]
set yfinal [dget [sinfunc [dget $result x] $pdata] fval]
.fi
.RE
.PP
The resulted dictionary contains the solution vector x with values of parameters, and miscellanious
information about fitting process, part of it we can print:
.PP
.RS 4n
.nf
puts "Chi^2 final: [format "%3f" [dget $result bestnorm]]"
puts "Chi^2 initial: [format "%3f" [dget $result orignorm]]"
puts "number of interations: [dget $result niter]"
puts "number of function evaluation: [dget $result nfev]"
set i -1
foreach xerr [dget $result xerror] xVal [dget $result x] xini $xInitial {
    puts [format "p[incr i]: %\&.3f ± %\&.3f" $xVal $xerr]
}
.fi
.RE
.PP
Results are:
.PP
.RS 4n
.nf
Chi^2 final: 0\&.321206
Chi^2 initial: 106\&.649503
number of interations: 8
number of function evaluation: 30
p0: 6\&.012 ± 0\&.468
p1: 11\&.013 ± 0\&.407
p2: 1\&.507 ± 0\&.484
.fi
.RE
.PP
Now we can plot fitted curve, initial data and curve before fitting:
.PP
.RS 4n
.nf
set chart [ticklecharts::chart new]
$chart Xaxis -name "x" -minorTick {show "True"} -min 0 -max 1 -type "value" -splitLine {show "True"}
$chart Yaxis -name "y" -minorTick {show "True"} -min 0 -max 2\&.5 -type "value" -splitLine {show "True"}
$chart SetOptions -title {} -legend {} -tooltip {} -animation "False" -backgroundColor "#212121" -toolbox {feature {dataZoom {yAxisIndex "none"}}}
$chart Add "lineSeries" -data [lmap xVal $x yVal $y {list $xVal $yVal}] -showAllSymbol "nothing" -name "Data"
$chart Add "lineSeries" -data [lmap xVal $x yVal $yinitial {list $xVal $yVal}] -showAllSymbol "nothing" -name "Initial"
$chart Add "lineSeries" -data [lmap xVal $x yVal $yfinal {list $xVal $yVal}] -showAllSymbol "nothing" -name "Fitted"
set fbasename [file rootname [file tail [info script]]]
$chart Render -outfile [file normalize [file join html_charts $fbasename\&.html]] -height 800px
.fi
.RE
.PP
Results are:
.PP
!ticklechart_mark_sinfit!
.SH "FIND MINIMUM OF 2D ROZENBROCK FUNCTION WITH DIFFERENTIAL EVOLUTION ALGORITHM"
.PP
In this example we run Differential Evolution algorithm to of of the stohastic optimization benchmark function,
the two variable Rozenbrock function:
.PP
.RS 4n
.nf
proc fRosenbrock {x pdata} {
    #        n - 1
    #        ____
    #        ╲                        2
    #   →     ╲          ⎛          2⎞            2
    # f(x) =  ╱    100 ⋅ ⎜x      - x ⎟  + ⎛1 - x ⎞
    #        ╱           ⎝ i + 1    i⎠    ⎝     i⎠
    #        ‾‾‾‾
    #        i = 1
    # Domain: x ∈ [-30, 30]
    #          i
    # Global min: f(1,\&.\&.\&.,1)=0
    set sum 0\&.0
    for {set i 0} {$i < [= {[llength $x]-1}]} {incr i} {
        set xi  [@ $x $i]
        set xip [@ $x [= {$i+1}]]
        set term1 [= {100\&.0*($xip-$xi*$xi)*($xip-$xi*$xi)}]
        set term2 [= {(1\&.0-$xi)*(1\&.0-$xi)}]
        set sum [= {$sum+$term1+$term2}]
    }
    return $sum
}
.fi
.RE
.PP
It has one true global minimum at x=1 and y=1 equal to 0\&.
.PP
After optimization we will plot 2D surface with best trajectory (best set of parameters for each generation) on
it\&.
.PP
First step is to create parameters objects \fI::tclopt::Parameter\fP to use together with optimization object with
proper domain ranges:
.PP
.RS 4n
.nf
lappend pars [Parameter new x 0\&.0 -lowlim -30 -uplim 30]
lappend pars [Parameter new y 0\&.0 -lowlim -30 -uplim 30]
.fi
.RE
.PP
Initial values of parameters does not matter in case of Differential Evolution optimization because the first
population is generated randomly at the start of the process by default (but you can provide the initial
population as a property to optimizator -specified -initpop matrix)\&.
.PP
Next step is the creaton of optimizator object \fI::tclopt::DE\fP with some properties provided:
.PP
.RS 4n
.nf
set optimizer [DE new -funct fRosenbrock -pdata {} -strategy rand/1/exp -genmax 3000 -np 60 -f 0\&.9 -cr 1 -seed 1 -history -histfreq 1]
.fi
.RE
.PP
Here we provide:
.TP
\(bu
funct - objective function (procedure)
.TP
\(bu
pdata - empty because we don't need to provide additional information to procedure except the parameters vector
.TP
\(bu
strategy - strategy used in optimization (see documentation for more info)
.TP
\(bu
genmax - maximum number of generation allowed
.TP
\(bu
np - size of population in each generation
.TP
\(bu
f - weight factor (mutation rate)
.TP
\(bu
cr - crossing over factor (crossover rate)
.TP
\(bu
seed - integer value for pseudo-random generator
.TP
\(bu
history - enable saving history data
.TP
\(bu
histfreq - how often we need to save data, each generation in our example
.PP
Add parameters object to optimizator:
.PP
.RS 4n
.nf
$optimizer addPars {*}$pars
.fi
.RE
.PP
After that we run optimization and get the results:
.PP
.RS 4n
.nf
set results [$optimizer run]
set trajectory [dict get $results besttraj]
set bestf [dict get $results history]
foreach genTr $trajectory genF $bestf {
    lappend optData [list {*}[dict get $genTr x] [dict get $genF bestf]]
}
.fi
.RE
.PP
Print the results:
.PP
.RS 4n
.nf
puts "Global minimum value of objective function: [format "%3e" [dget $results objfunc]]"
puts [format "x=%3f, y=%3f" {*}[dict get $results x]]
puts "Number of generation: [dget $results generation]"
puts "Number of function evaluation: [dget $results nfev]"
puts "Convergence info: [dget $results info]"
.fi
.RE
.PP
Result are:
.PP
.RS 4n
.nf
Global minimum value of objective function: 2\&.196816e-09
x=1\&.000003, y=1\&.000010
Number of generation: 124
Number of function evaluation: 7500
Convergence info: Optimization stopped due to crossing threshold 'abstol+reltol*abs(mean)=1\&.010542152047526e-6' of objective function population member standard deviation
.fi
.RE
.PP
We achieve pretty good results, and process was stopped beacause of reaching the default stopping criteria - the
standard deviation across population crossed the threshold that is constructed fromsum of absolute value
(default 1e-6) and relative tolerance multiplied to mean value of this population (default relative tolerance
value is 0\&.01)\&. Basically, the less spreaded the population is and each member is closer to mean value, the
more closer we are to global minimum at which point no more advancing could be reached\&.
.PP
We can also set the stopping criteria to be the reaching of certain value objective function with
-threshold value option of optimizer\&.
.PP
Finally we can plot the final surface and best trajectory:
.PP
.RS 4n
.nf
# generate data for Rosenbrock surface
proc surface3dData {xrange yrange} {
    set data {}
    foreach t0 [lseq {*}$xrange] {
        set y $t0
        foreach t1 [lseq {*}$yrange] {
            set x $t1
            set z [fRosenbrock [list $x $y] {}]
            lappend data [list $x $y $z]
        }
    }
    return $data
}
# plot Rosenbrock surface with best trajectory
set chart3D [ticklecharts::chart3D new]
$chart3D SetOptions -tooltip {} -grid3D {viewControl {} axisPointer {show false}} -visualMap [list type "continuous" show "False" dimension 2 min 0 max 30000 seriesIndex {0} inRange [list color [list "#313695 #4575b4 #74add1 #abd9e9 #e0f3f8 #ffffbf #fee090 #fdae61 #f46d43 #d73027 #a50026"]]]
$chart3D Xaxis3D -type "value" -name "x" -axisTick {show "True"} -show "True" -min -7 -max 7
$chart3D Yaxis3D -type "value" -name "y" -axisTick {show "True"} -show "True" -min -15 -max 30
$chart3D Zaxis3D -type "value" -name "z" -axisTick {show "True"} -show "True"
set data [surface3dData {-15 30 0\&.1} {-7 7 0\&.1}]
$chart3D Add "surfaceSeries" -name "Rosenbrock surface" -wireframe {show "False"} -data $data -itemStyle {opacity 0\&.7} -shading "lambert"
$chart3D Add "scatter3DSeries" -data $optData -itemStyle {color "#f79802" borderColor "#000000"} -symbolSize 4
$chart3D Add "line3DSeries" -data $optData -lineStyle {width 2 opacity 1} -silent "True"
set seFmt [ticklecharts::jsfunc new {
    function (p) { return p\&.dataIndex === 0 ? "start" : "end"; }
}]
$chart3D Add "scatter3DSeries" -coordinateSystem cartesian3D -data [list [lindex $optData 0] [lindex $optData end]] -symbolSize 8 -itemStyle {color "#ff0000" borderColor "#000000"}  -label [dict create show true position top formatter $seFmt textStyle [dict create color black fontSize 12 fontWeight bold]]
set fbasename [file rootname [file tail [info script]]]
$chart3D Render -outfile [file normalize [file join html_charts $fbasename\&.html]] -height 800px
.fi
.RE
.PP
Results are:
.PP
!ticklechart_mark_diffEvolution_Rozenbrock!

