'\"
'\" '\" Copyright (c) George Yashin
'\"
.TH "tclopt" 3tcl 0\&.21 "tclopt" "Tcl wrapper for C optimization procedures"
.SH NAME
tclopt - Commands in namespace tclopt
.SH SYNOPSIS
\fBOBJECT constructor\fP \fI-funct value -strategy value -pdata value ?-genmax value? ?-refresh value? ?-np value? ?-f value? ?-cr value? ?-seed value? ?-abstol value? ?-reltol value? ?-debug? ?-random|specified -initpop value?\fP
.br
\fBOBJECT addPars\fP \fI?args?\fP
.br
\fBOBJECT getAllPars\fP \fI?args?\fP
.br
\fBOBJECT getAllParsNames\fP \fI?args?\fP
.br
\fBOBJECT run\fP
.br
\fBOBJECT duplListCheck\fP \fIlist\fP
.br
\fBGSA create OBJNAME\fP \fI?args?\fP
.br
\fBGSA new\fP \fI?args?\fP
.br
\fBOBJECT addPars\fP \fI?args?\fP
.br
\fBOBJECT getAllPars\fP \fI?args?\fP
.br
\fBOBJECT getAllParsNames\fP \fI?args?\fP
.br
\fBOBJECT run\fP
.br
\fBOBJECT constructor\fP \fI-funct value -m value -pdata value ?-ftol value? ?-xtol value? ?-gtol value? ?-stepfactor value? ?-covtol value? ?-maxiter value? ?-maxfev value? ?-epsfcn value? ?-nofinitecheck?\fP
.br
\fBOBJECT addPars\fP \fI?args?\fP
.br
\fBOBJECT getAllPars\fP \fI?args?\fP
.br
\fBOBJECT getAllParsNames\fP \fI?args?\fP
.br
\fBOBJECT run\fP
.br
\fBParameter create OBJNAME\fP \fI?args?\fP
.br
\fBParameter new\fP \fI?args?\fP
.br
\fBOBJECT constructor\fP \fIvalue value ?-fixed? ?-lowlim value? ?-uplim value? ?-step value? ?-relstep value? ?-side value? ?-debugder -debugreltol value -debugabstol value?\fP
.br
.SH ::TCLOPT
.SH CLASSES
.PP
.RS -4n
\fBDE\fR (::tclopt)
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
constructor
Constructor for the class\&.
.TP
addPars
Not documented\&.
.TP
configure
Configure properties\&.
.TP
duplListCheck
See \fIDuplChecker\&.duplListCheck\fP
.TP
getAllPars
Gets references of all parameters objects\&.
.TP
getAllParsNames
Gets names of all parameters\&.
.TP
run
Runs optimization\&.
.RE
.PP
\fBProperties\fR
.PP
Readable: -abstol, -cr, -d, -debug, -f, -funct, -genmax, -initpop, -initype, -np, -pdata, -refresh, -reltol, -results, -seed, -strategy
.PP
Writable: -abstol, -cr, -d, -debug, -f, -funct, -genmax, -initpop, -initype, -np, -pdata, -refresh, -reltol, -results, -seed, -strategy
.PP
\fBMixins\fR
.PP
\fIDuplChecker\fP
.PP
.RS -4n
\fBconstructor\fR (::tclopt::DE)
.RE
.PP
Creates optimization object that tuns optimization using modified Differential Evolution algorithm\&.
.RS 4n\fBOBJECT constructor\fP \fI-funct value -strategy value -pdata value ?-genmax value? ?-refresh value? ?-np value? ?-f value? ?-cr value? ?-seed value? ?-abstol value? ?-reltol value? ?-debug? ?-random|specified -initpop value?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-abstol
Absolute tolerance\&. Controls termination of optimization\&. Default 1e-6\&.
.TP
-cr
Crossing over factor (crossover rate)\&. Controls the probability of mixing components from the target vector and the mutant vector to form a trial vector\&. It determines how much of the trial vector inherits its components from the mutant vector versus the target vector\&. A high crossover rate means that more components will come from the mutant vector, promoting exploration of new solutions\&. Conversely, a low crossover rate results in more components being taken from the target vector, which can help maintain existing solutions and refine them\&. The typical range for CR is between 0\&.0 and 1\&.0\&. Default is 0\&.9\&.
.TP
-debug
Print debug messages during optimization\&.
.TP
-f
Weight factor (mutation rate)\&. Controls the amplification of the differential variation between individuals\&. It is a scaling factor applied to the difference between two randomly selected population vectors before adding the result to a third vector to create a mutant vector (exact mechanism is dependent on selected strategy)\&. The mutation rate influences the algorithm's ability to explore the search space; a higher value of f increases the diversity of the mutant vectors, leading to broader exploration, while a lower value encourages convergence by making smaller adjustments\&. The typical range for f is between 0\&.4 and 1\&.0, though values outside this range can be used depending on the problem characteristics\&. Default is 0\&.9\&.
.TP
-funct
Name of the procedure that should be minimized\&.
.TP
-genmax
Maximum number of generations\&. Controls termination of optimization\&. Default 3000\&.
.TP
-initpop
List of lists (matrix) with size np x d, requires -specified\&.
.TP
-np
Population size\&. Represents number of random parameter vector per generation\&. As a first guess for the value it is recommended to set it from 5 to 10 times the number of parameters\&. Default is 20\&.
.TP
-pdata
List or dictionary that provides private data to funct that is needed to evaluate residuals\&. Usually it contains x and y values lists, but you can provide any data necessary for function residuals evaluation\&. Will be passed upon each function evaluation without modification\&.
.TP
-random
Select population initialization with random values over the individual parameters ranges\&.
.TP
-refresh
Output refresh cycle\&. Represent the frequency of printing debug information to stdout\&.
.TP
-reltol
Relative tolerance\&. Controls termination of optimization\&. Default 1e-2\&.
.TP
-seed
Random seed\&.
.TP
-specified
Select population initialization with specified population values, requires -initpop\&.
.TP
-strategy
Choice of strategy\&. Possible strategies: best/1/exp rand/1/exp rand-to-best/1/exp best/2/exp rand/2/exp best/1/bin rand/1/bin rand-to-best/1/bin best/2/bin rand/2/bin\&.
.RE
.PP
\fBDescription\fR
.PP
Class implements the Differential Evolution (DE) algorithm to solve global optimization problems over
continuous parameter spaces\&. Typically, it is used to minimize a user-supplied objective function by evolving
a population of candidate solutions through mutation, crossover, and selection\&.
.PP
Differential Evolution is a stochastic, population-based optimizer that works well for non-linear,
non-differentiable, and multi-modal objective functions\&. It does not require gradient information and is
effective in high-dimensional or rugged search spaces\&. The user-supplied objective function should take a
vector of parameters as input and return a scalar value to be minimized\&. For example, the objective function
might compute the volume of material used in a structure given its geometric parameters, the error rate of a
machine learning model, or the energy of a physical system\&. DE begins by initializing a population of random
candidate solutions within given parameter bounds and iteratively refines them by combining members of the
population and selecting better solutions over generations\&.
.PP
Simple constraints are placed on parameter values by adding objects of class \fI::tclopt::Parameter\fP to DE with
method \fI::tclopt::DE::addPars\fP\&.  For details of how to specify constraints, please look at the description of
\fI::tclopt::Parameter\fP class\&. Please note, that order in which we attach parameters objects is the order in
which values will be supplied to minimized function, and the order in which resulted will be written to X
property of the class\&.
.SS "GENERAL ADVICES"
.PP
1)  f is usually between 0\&.5 and 1 (in rare cases > 1)
2)  cr is between 0 and 1 with 0\&., 0\&.3, 0\&.7 and 1\&. being worth to be tried first
3)  To start off np = 10*d is a reasonable choice\&. Increase NP if misconvergence happens\&.
4)  If you increase np, f usually has to be decreased
5)  When the DE/best\&.\&.\&. schemes fail DE/rand\&.\&.\&. usually works and vice versa
.SS "STRATEGIES OVERVIEW"
.PP
Naming convention for strategies: x/y/z, where:
.TP
\(bu
x - a string which denotes the vector to be perturbed (mutated)
.TP
\(bu
y - number of difference vectors taken for perturbation (mutation) of x
.TP
\(bu
z - crossover method (exp = exponential, bin = binomial)
.PP
\fBMutation\fR
.PP
Combination of x and y gives following mutation function:
.PP
best/1:
.PP
.RS 4n
.nf
 →    →         →     →
 u  = x  + f ⋅ ⎛x   - x  ⎞
  i    b       ⎝ r2    r3⎠
.fi
.RE
.PP
rand/1:
.PP
.RS 4n
.nf
 →    →         →     →
 u  = x  + f ⋅ ⎛x   - x  ⎞
  i    r1      ⎝ r2    r3⎠
.fi
.RE
.PP
rand-to-best/1 (custom variant):
.PP
.RS 4n
.nf
 →    →         →     →           →     →
 u  = x  + f ⋅ ⎛x   - x  ⎞ + f ⋅ ⎛x   - x  ⎞
  i    i       ⎝ b     i ⎠       ⎝ r1    r2⎠
.fi
.RE
.PP
best/2:
.PP
.RS 4n
.nf
 →    →         →     →     →     →
 u  = x  + f ⋅ ⎛x   + x   - x   - x  ⎞
  i    b       ⎝ r1    r2    r3    r4⎠
.fi
.RE
.PP
rand/2:
.PP
.RS 4n
.nf
 →    →         →     →     →     →
 u  = x  + f ⋅ ⎛x   + x   - x   - x  ⎞
  i    r5      ⎝ r1    r2    r3    r4⎠
.fi
.RE
.PP
x_i - trial vector, x_b - best vector, x_rn - randomly selected individuals from population\&.
.PP
A crossover operation between the new generated mutant vector v_i and the target vector x_i is used to further
increase the diversity of the new candidate solution\&.
.PP
\fBExponential crossover\fR
.PP
In exponential crossover, a contiguous block of dimensions is modified, starting from a random index, and
continues as long as random values are less than CR\&. The mutation happens inline during crossover, and
wrapping around is supported\&.
.PP
.RS 4n
.nf
Example (D = 10, n = 3, L = 4):

Parent x_i:         [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9]
Exponential mask:             →  →  →  →
                             n  n+1 n+2 n+3

Trial u_i:          [x0 x1 x2 v3 v4 v5 v6 x7 x8 x9]
                            ↑ mutated from DE strategy
.fi
.RE
.TP
\(bu
Starts from a random index n ∈ [0, D)
.TP
\(bu
Replaces a contiguous block of components (dimension-wise)
.TP
\(bu
Continues as long as rand() < CR, up to D components
.TP
\(bu
Mutation and crossover are applied together in the code, not as separate stages\&.
.PP
\fBBinomial crossover\fR
.PP
In binomial crossover, each dimension has an independent probability CR of being replaced by the mutant
vector\&. At least one dimension is guaranteed to be copied from the mutant (typically by forcing one fixed
index to be included)\&.
.PP
.RS 4n
.nf
Example (D = 10):

Parent x_i:         [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9]
Random mask:         ✗  ✓  ✗  ✗  ✓  ✗  ✓  ✗  ✗  ✓
Mutant values:      [v0 v1 v2 v3 v4 v5 v6 v7 v8 v9]

Trial u_i:          [x0 v1 x2 x3 v4 x5 v6 x7 x8 v9]
                         ↑       ↑       ↑     ↑
                   replaced where rand() < CR
.fi
.RE
.TP
\(bu
Applies independent crossover decision for each dimension
.TP
\(bu
Starts at a random dimension n, iterates D steps circularly
.TP
\(bu
Each dimension is replaced with probability CR
.TP
\(bu
Ensures at least one dimension is modified (usually last)
.TP
\(bu
Mutation and crossover are applied together in the code, not as separate stages\&.
.PP
\fBSummary of strategies\fR
.PP
.RS 4n
.nf
+----+----------+-----------------------------+-----+----------------------------------+
| ID |  Base    | Difference                  | XOV | Description                      |
+----+----------+-----------------------------+-----+----------------------------------+
| 1  | best     | r2 - r3                     | exp | Exploitative, may misconv        |
| 2  | r1       | r2 - r3                     | exp | Balanced, exploratory            |
|    |          |                             |     | Try e\&.g\&. F=0\&.7 and CR=0\&.5 first  |
| 3  | x_i      | (best - x_i) + (r1 - r2)    | exp | Hybrid: pull + variation         |
|    |          |                             |     | Try e\&.g  F=0\&.85 and CR=1 first   |
| 4  | best     | (r1 + r2) - (r3 + r4)       | exp | Exploratory, best-guided         |
| 5  | r5       | (r1 + r2) - (r3 + r4)       | exp | Fully random, robust             |
| 6  | best     | r2 - r3                     | bin | Same as 1, binomial crossover    |
| 7  | r1       | r2 - r3                     | bin | Same as 2, binomial crossover    |
| 8  | x_i      | (best - x_i) + (r1 - r2)    | bin | Same as 3, binomial crossover    |
| 9  | best     | (r1 + r2) - (r3 + r4)       | bin | Same as 4, binomial crossover    |
| 10 | r5       | (r1 + r2) - (r3 + r4)       | bin | Same as 5, binomial crossover    |
+----+----------+-----------------------------+-----+----------------------------------+
.fi
.RE
.PP
See more information in \fItechreport\fP [URL: http://mirror\&.krakadikt\&.com/2004-11-13-genetic-algorithms/www\&.icsi\&.berkeley\&.edu/%257Estorn/deshort1\&.ps]
.PP
Description of keys and data in returned dictionary:
.RS 4n
.TP
-objfunc
Final value of object (cost) function funct
.TP
-x
Final vector of parameters\&.
.TP
-generation
Number of generations\&.
.TP
-strategy
Strategy used for optimization\&.
.TP
-std
Standard deviation of final population\&.
.RE
.PP
You can also access result dictionary with [my configure results]\&.
.PP
\fBReturn value\fR
.PP
object of class
.PP
.RS -4n
\fBaddPars\fR (::tclopt::DE)
.RE
.RS 4n\fBOBJECT addPars\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
.RS -4n
\fBgetAllPars\fR (::tclopt::DE)
.RE
.PP
Gets references of all parameters objects\&.
.RS 4n\fBOBJECT getAllPars\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
\fBReturn value\fR
.PP
list of elements names
.PP
.RS -4n
\fBgetAllParsNames\fR (::tclopt::DE)
.RE
.PP
Gets names of all parameters\&.
.RS 4n\fBOBJECT getAllParsNames\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
\fBReturn value\fR
.PP
list of elements names
.PP
.RS -4n
\fBrun\fR (::tclopt::DE)
.RE
.PP
Runs optimization\&.
.RS 4n\fBOBJECT run\fP
.br
.RE
.PP
\fBDescription\fR
.SH "INITIALIZE RANDOM NUMBER GENERATOR"
.PP
\fBReturn value\fR
.PP
dictionary containing resulted data
.PP
.RS -4n
\fBDuplChecker\fR (::tclopt)
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
configure
Configure properties\&.
.TP
duplListCheck
Checks if list contains duplicates\&.
.RE
.PP
\fBSubclasses\fR
.PP
\fIMpfit\fP, \fIDE\fP, \fIGSA\fP
.PP
.RS -4n
\fBduplListCheck\fR (::tclopt::DuplChecker)
.RE
.PP
Checks if list contains duplicates\&.
.RS 4n\fBOBJECT duplListCheck\fP \fIlist\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
list
List to check\&.
.RE
.PP
\fBReturn value\fR
.PP
0 if there are no duplicates and 1 if there are\&.
.PP
.RS -4n
\fBGSA\fR (::tclopt)
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
constructor
Constructor for the class\&.
.TP
addPars
Not documented\&.
.TP
configure
Configure properties\&.
.TP
duplListCheck
See \fIDuplChecker\&.duplListCheck\fP
.TP
getAllPars
Gets references of all parameters objects\&.
.TP
getAllParsNames
Gets names of all parameters\&.
.TP
run
Not documented\&.
.RE
.PP
\fBProperties\fR
.PP
Readable: -debug, -funct, -initype, -maxfev, -maxinniter, -maxiter, -maxratio, -mininniter, -nbase, -ntrial, -pdata, -qa, -qv, -r, -results, -seed, -temp0, -threshold, -tmin
.PP
Writable: -debug, -funct, -initype, -maxfev, -maxinniter, -maxiter, -maxratio, -mininniter, -nbase, -ntrial, -pdata, -qa, -qv, -r, -results, -seed, -temp0, -threshold, -tmin
.PP
\fBMixins\fR
.PP
\fIDuplChecker\fP
.PP
.RS -4n
\fBconstructor\fR (::tclopt::GSA)
.RE
.RS 4n\fBGSA create OBJNAME\fP \fI?args?\fP
.br
\fBGSA new\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
.RS -4n
\fBaddPars\fR (::tclopt::GSA)
.RE
.RS 4n\fBOBJECT addPars\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
.RS -4n
\fBgetAllPars\fR (::tclopt::GSA)
.RE
.PP
Gets references of all parameters objects\&.
.RS 4n\fBOBJECT getAllPars\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
\fBReturn value\fR
.PP
list of elements names
.PP
.RS -4n
\fBgetAllParsNames\fR (::tclopt::GSA)
.RE
.PP
Gets names of all parameters\&.
.RS 4n\fBOBJECT getAllParsNames\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
\fBReturn value\fR
.PP
list of elements names
.PP
.RS -4n
\fBrun\fR (::tclopt::GSA)
.RE
.RS 4n\fBOBJECT run\fP
.br
.RE
.PP
.RS -4n
\fBMpfit\fR (::tclopt)
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
constructor
Constructor for the class\&.
.TP
addPars
Not documented\&.
.TP
configure
Configure properties\&.
.TP
duplListCheck
See \fIDuplChecker\&.duplListCheck\fP
.TP
getAllPars
Gets references of all parameters objects\&.
.TP
getAllParsNames
Gets names of all parameters\&.
.TP
run
Runs optimization\&.
.RE
.PP
\fBProperties\fR
.PP
Readable: -covtol, -epsfcn, -ftol, -funct, -gtol, -m, -maxfev, -maxiter, -nofinitecheck, -pdata, -results, -stepfactor, -xtol
.PP
Writable: -covtol, -epsfcn, -ftol, -funct, -gtol, -m, -maxfev, -maxiter, -nofinitecheck, -pdata, -results, -stepfactor, -xtol
.PP
\fBMixins\fR
.PP
\fIDuplChecker\fP
.PP
.RS -4n
\fBconstructor\fR (::tclopt::Mpfit)
.RE
.PP
Creates optimization object that does least squares fitting using modified Levenberg-Marquardt algorithm\&.
.RS 4n\fBOBJECT constructor\fP \fI-funct value -m value -pdata value ?-ftol value? ?-xtol value? ?-gtol value? ?-stepfactor value? ?-covtol value? ?-maxiter value? ?-maxfev value? ?-epsfcn value? ?-nofinitecheck?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-covtol
Range tolerance for covariance calculation\&. Value must be of the type float more than zero, default is 1e-14\&.
.TP
-epsfcn
Finite derivative step size\&. Value must be of the type float more than zero, default is 2\&.2204460e-16\&.
.TP
-ftol
Control termination of mpfit\&. Termination occurs when both the actual and predicted relative reductions in the sum of squares are at most ftol\&. Therefore, ftol measures the relative error desired in the sum of squares\&. Value must be of the type float more than zero, default is 1e-10\&.
.TP
-funct
Name of the procedure that should be minimized\&.
.TP
-gtol
Control termination of mpfit\&. Termination occurs when the cosine of the angle between fvec and any column of the jacobian is at most gtol in absolute value\&. Therefore, gtol measures the orthogonality desired between the function vector and the columns of the jacobian\&. Value must be of the type float more than zero, default is 1e-10\&.
.TP
-m
Number of data points\&.
.TP
-maxfev
Control termination of mpfit\&. Termination occurs when the number of calls to funct is at least maxfev by the end of an iteration\&. Value must be the positive integer, default is 0\&. If it equals to 0, number of evaluations is not restricted\&.
.TP
-maxiter
Maximum number of iterations\&. If maxiter equal to 0, then basic error checking is done, and parameter errors/covariances are estimated based on input arameter values, but no fitting iterations are done\&. Value must be the positive integer, default is 200\&.
.TP
-nofinitecheck
Enable check for infinite quantities, default is off\&.
.TP
-pdata
List or dictionary that provides private data to funct that is needed to evaluate residuals\&. Usually it contains x and y values lists, but you can provide any data necessary for function residuals evaluation\&. Will be passed upon each function evaluation without modification\&.
.TP
-stepfactor
Used in determining the initial step bound\&. This bound is set to the product of factor and the euclidean norm of diag*x if nonzero, or else to factor itself\&. In most cases factor should lie in the interval (\&.1,100\&.)\&. 100\&. is a generally recommended value\&. Value must be of the type float more than zero, default is 100\&.
.TP
-xtol
Control termination of mpfit\&. Termination occurs when the relative error between two consecutive iterates is at most xtol\&. Therefore, xtol measures the relative error desired in the approximate solution\&. Value must be of the type float more than zero, default is 1e-10\&.
.RE
.PP
\fBDescription\fR
.PP
Class uses the Levenberg-Marquardt technique to solve the least-squares problem\&. In its typical use, it will
be used to fit a user-supplied function (the "model") to user-supplied data points (the "data") by adjusting a
set of parameters\&. mpfit is based upon MINPACK-1 (LMDIF\&.F) by More' and collaborators\&.
The user-supplied function should compute an array of weighted deviations between model and data\&. In a typical
scientific problem the residuals should be weighted so that each deviate has a gaussian sigma of 1\&.0\&. If x
represents values of the independent variable, y represents a measurement for each value of x, and err
represents the error in the measurements, then the deviates could be calculated as follows:
.PP
.RS 4n
.nf
for {set i 0} {$i<$m} {incr i} {
    lset deviates $i [expr {([lindex $y $i] - [f [lindex $x $i]])/[lindex $err $i]}]
}
.fi
.RE
.PP
where m is the number of data points, and where f is the function representing the model evaluated at x\&. If ERR
are the 1-sigma uncertainties in Y, then the sum of deviates squared will be the total chi-squared value, which
mpfit will seek to minimize\&.
Simple constraints are placed on parameter values by adding objects of class \fI::tclopt::ParameterMpfit\fP to
mpfit with method \fI::tclopt::Mpfit::addPars\fP, where other parameter-specific options can be set\&.
For details of how to specify constraints, please look at the
description of \fI::tclopt::ParameterMpfit\fP class\&. Please note, that order in which we attach parameters objects
is the order in which values will be supplied to minimized function, and the order in which resulted will
be written to X property of the class\&.
Example of user defined function (using linear equation t=a+b*x):
.PP
.RS 4n
.nf
proc f {xall pdata args} {
    set x [dget $pdata x]
    set y [dget $pdata y]
    set ey [dget $pdata ey]
    foreach xVal $x yVal $y eyVal $ey {
        set f [= {[@ $xall 0]+[@ $xall 1]*$xVal}]
        lappend fval [= {($yVal-$f)/$eyVal}]
    }
    return [dcreate fvec $fval]
}
.fi
.RE
.PP
where xall is list of initial parameters values, pdata - dictionary that contains x, y and ey lists with
length m\&. It returns dictionary with residuals values\&.
Alternative form of function f could also provide analytical derivatives:
.PP
.RS 4n
.nf
proc quadfunc {xall pdata args} {
    set x [dget $pdata x]
    set y [dget $pdata y]
    set ey [dget $pdata ey]
    foreach xVal $x yVal $y eyVal $ey {
        lappend fvec [= {($yVal-[@ $xall 0]-[@ $xall 1]*$xVal-[@ $xall 2]*$xVal*$xVal)/$eyVal}]
    }
    if {[@ $args 0]!=""} {
        set derivs [@ $args 0]
        foreach deriv $derivs {
            if {$deriv==0} {
                foreach xVal $x yVal $y eyVal $ey {
                    lappend dvec [= {-1/$eyVal}]
                }
            }
            if {$deriv==1} {
                foreach xVal $x yVal $y eyVal $ey {
                    lappend dvec [= {(-$xVal)/$eyVal}]
                }
            }
            if {$deriv==2} {
                foreach xVal $x yVal $y eyVal $ey {
                    lappend dvec [= {(-$xVal*$xVal)/$eyVal}]
                }
            }
        }
        return [dcreate fvec $fvec dvec $dvec]
    } else {
        return [dcreate fvec $fvec]
    }
}
.fi
.RE
.PP
The first element of the args list is a list specifying the ordinal numbers of the parameters for which we
need to calculate the analytical derivative\&. In this case, the returned dvec list contains the derivative at
each x point for each specified parameter, following the same order as in the input list\&. For example, if the
input list is {0, 2} and the number m of x points is 3, the dvec list will look like this:
.PP
.RS 4n
.nf
⎛⎛df ⎞   ⎛df ⎞   ⎛df ⎞   ⎛df ⎞   ⎛df ⎞   ⎛df ⎞  ⎞
⎜⎜───⎟   ⎜───⎟   ⎜───⎟   ⎜───⎟   ⎜───⎟   ⎜───⎟  ⎟
⎜⎝dp0⎠   ⎝dp0⎠   ⎝dp0⎠   ⎝dp2⎠   ⎝dp2⎠   ⎝dp2⎠  ⎟
⎝     x0      x1      x2      x0      x1      x2⎠
.fi
.RE
.PP
Description of keys and data in returned dictionary:
.RS 4n
.TP
-bestnorm
Final chi^2\&.
.TP
-orignorm
Starting value of chi^2\&.
.TP
-status
Fitting status code\&.
.TP
-niter
Number of iterations\&.
.TP
-nfev
Number of function evaluations\&.
.TP
-npar
Total number of parameters\&.
.TP
-nfree
Number of free parameters\&.
.TP
-npegged
Number of pegged parameters\&.
.TP
-nfunc
Number of residuals (= num\&. of data points)
.TP
-resid
List of final residuals\&.
.TP
-xerror
Final parameter uncertainties (1-sigma), in the order of elements in Pars property dictionary\&.
.TP
-x
Final parameters values list in the order of elements in Pars property dictionary\&.
.TP
-debug
String with derivatives debugging output\&.
.TP
-covar
Final parameters covariance matrix\&.
.RE
.PP
You can also access result dictionary with [my configure results]\&.
.PP
\fBReturn value\fR
.PP
object of class
.PP
.RS -4n
\fBaddPars\fR (::tclopt::Mpfit)
.RE
.RS 4n\fBOBJECT addPars\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
.RS -4n
\fBgetAllPars\fR (::tclopt::Mpfit)
.RE
.PP
Gets references of all parameters objects\&.
.RS 4n\fBOBJECT getAllPars\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
\fBReturn value\fR
.PP
list of elements names
.PP
.RS -4n
\fBgetAllParsNames\fR (::tclopt::Mpfit)
.RE
.PP
Gets names of all parameters\&.
.RS 4n\fBOBJECT getAllParsNames\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
\fBReturn value\fR
.PP
list of elements names
.PP
.RS -4n
\fBrun\fR (::tclopt::Mpfit)
.RE
.PP
Runs optimization\&.
.RS 4n\fBOBJECT run\fP
.br
.RE
.PP
\fBReturn value\fR
.PP
dictionary containing resulted data
.PP
.RS -4n
\fBParameter\fR (::tclopt)
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
constructor
Constructor for the class\&.
.TP
configure
Configure properties\&.
.RE
.PP
\fBProperties\fR
.PP
Readable: -initval, -lowlim, -name, -uplim
.PP
Writable: -initval, -lowlim, -name, -uplim
.PP
\fBSubclasses\fR
.PP
\fIParameterMpfit\fP
.PP
.RS -4n
\fBconstructor\fR (::tclopt::Parameter)
.RE
.RS 4n\fBParameter create OBJNAME\fP \fI?args?\fP
.br
\fBParameter new\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
.RS -4n
\fBParameterMpfit\fR (::tclopt)
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
constructor
Constructor for the class\&.
.TP
configure
Configure properties\&.
.RE
.PP
\fBProperties\fR
.PP
Readable: -debugder, -derivabstol, -derivreltol, -fixed, -initval, -lowlim, -name, -relstep, -side, -step, -uplim
.PP
Writable: -debugder, -derivabstol, -derivreltol, -fixed, -initval, -lowlim, -name, -relstep, -side, -step, -uplim
.PP
\fBSuperclasses\fR
.PP
\fIParameter\fP
.PP
.RS -4n
\fBconstructor\fR (::tclopt::ParameterMpfit)
.RE
.PP
Creates parameter object for \fI::tclopt::Mpfit\fP class\&.
.RS 4n\fBOBJECT constructor\fP \fIvalue value ?-fixed? ?-lowlim value? ?-uplim value? ?-step value? ?-relstep value? ?-side value? ?-debugder -debugreltol value -debugabstol value?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-debugabstol
Absolute error that controls printing of derivatives comparison if absolute error exceeds this value\&. Requires -debugder and -debugreltol\&.
.TP
-debugder
Switch to enable console debug logging of user-computed derivatives, as described above\&. Note that when debugging is enabled, then -side should be set to auto, right, left or both, depending on which numerical derivative you wish to compare to\&. Requires -debugreltol and -debugabstol values\&.
.TP
-debugreltol
Relative error that controls printing of derivatives comparison if relative error exceeds this value\&. Requires -debugder and -debugabstol\&.
.TP
-fixed
Specify that parameter is fixed during optimization, optional\&.
.TP
-lowlim
Specify lower limit for parameter, must be lower than upper limit if upper limit is provided, optional\&.
.TP
-relstep
The \fIrelative\fP step size to be used in calculating the numerical derivatives\&. This number is the fractional size of the step, compared to the parameter value\&. This value supercedes the -step setting\&. If the parameter is zero, then a default step size is chosen\&.
.TP
-side
The sidedness of the finite difference when computing numerical derivatives\&. This field can take four values: auto : one-sided derivative computed automatically, right : one-sided derivative (f(x+h)-f(x))/h, left : one-sided derivative (f(x)-f(x-h))/h, both : two-sided derivative (f(x+h)-f(x-h))/(2*h), an : user-computed explicit derivatives, where h is the -step parameter described above\&. The "automatic" one-sided derivative method will chose a direction for the finite difference which does not violate any constraints\&. The other methods do not perform this check\&. The two-sided method is in principle more precise, but requires twice as many function evaluations\&. Default is auto\&.
.TP
-step
The step size to be used in calculating the numerical derivatives\&.  If set to zero, then the step size is computed automatically, optional\&.
.TP
-uplim
Specify upper limit for parameter, must be higher than lower limit if lower limit is provided, optional\&.
.TP
initval
Initial value of parameter\&.
.TP
name
Name of the parameter\&.
.RE
.PP
\fBDescription\fR
.PP
Example of building 4 parameters with different constraints:
.PP
.RS 4n
.nf
set par0 [::tclopt::ParameterMpfit new a 1\&.0 -fixed -side both]
set par1 [::tclopt::ParameterMpfit new b 2\&.0]
set par2 [::tclopt::ParameterMpfit new c 0\&.0 -fixed]
set par3 [::tclopt::ParameterMpfit new d 0\&.1 -lowlim -0\&.3 -uplim 0\&.2]
.fi
.RE

