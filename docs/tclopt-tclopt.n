'\"
'\" '\" Copyright (c) George Yashin
'\"
.TH "tclopt" 3tcl 0\&.3 "tclopt" "Tcl wrapper for C optimization procedures"
.SH NAME
tclopt - Commands in namespace tclopt
.SH SYNOPSIS
\fBOBJECT constructor\fP \fI-funct value -strategy value -pdata value ?-genmax value? ?-refresh value? ?-np value? ?-f value? ?-cr value? ?-seed value? ?-abstol value? ?-reltol value? ?-debug? ?-random|specified -initpop value? ?-history? ?-histfreq value? ?-savepop?\fP
.br
\fBDEOBJ run\fP
.br
\fBDuplChecker create OBJNAME\fP
.br
\fBDuplChecker new\fP
.br
\fBDUPLCHECKEROBJ duplListCheck\fP \fIlist\fP
.br
\fBOBJECT constructor\fP \fI-funct value -pdata value ?-maxiter value? ?-mininniter value? ?-maxfev value? ?-seed value? ?-ntrial value? ?-nbase value? ?-qv value? ?-qa value? ?-tmin value? ?-temp0 value? ?-debug? ?-threshold value? ?-random|specified -initpop value? ?-history? ?-histfreq value? ?-savemoves?\fP
.br
\fBGSAOBJ run\fP
.br
\fBOBJECT constructor\fP \fI-funct value -pdata value ?-gradient value? ?-dstepmin value? ?-dstepscale value? ?-epsilon value? ?-past value? ?-delta value? ?-maxiter value? ?-linesearch value? ?-maxlinesearch value? ?-minstep value? ?-maxstep value? ?-ftol value? ?-wolfe value? ?-gtol value? ?-xtol value? ?-condition value? ?-orthantwisec value ?-orthantwisestart value? ?-orthantwiseend value?? ?-history? ?-histfreq value?\fP
.br
\fBLBFGSOBJ run\fP
.br
\fBOBJECT constructor\fP \fI-funct value -m value -pdata value ?-ftol value? ?-xtol value? ?-gtol value? ?-stepfactor value? ?-covtol value? ?-maxiter value? ?-maxfev value? ?-epsfcn value? ?-nofinitecheck? ?-refresh value? ?-debug? ?-history? ?-histfreq value?\fP
.br
\fBMPFITOBJ run\fP
.br
\fBOptimization create OBJNAME\fP
.br
\fBOptimization new\fP
.br
\fBOPTIMIZATIONOBJ addPars\fP \fI?args?\fP
.br
\fBOPTIMIZATIONOBJ getAllPars\fP \fI?args?\fP
.br
\fBOPTIMIZATIONOBJ getAllParsNames\fP \fI?args?\fP
.br
\fBOBJECT constructor\fP \fIvalue value ?-fixed? ?-lowlim value? ?-uplim value? ?-step value? ?-relstep value? ?-side value? ?-debugder -debugreltol value -debugabstol value?\fP
.br
\fBOBJECT constructor\fP \fIvalue value ?-fixed? ?-lowlim value? ?-uplim value? ?-step value? ?-relstep value? ?-side value? ?-debugder -debugreltol value -debugabstol value?\fP
.br
.SH ::TCLOPT
.SH CLASSES
.PP
.RS -4n
\fBDE\fR (::tclopt)
.RE
.PP
Class implements the Differential Evolution (DE) algorithm to solve global optimization problems over
continuous parameter spaces\&. Typically, it is used to minimize a user-supplied objective function by
evolving a population of candidate solutions through mutation, crossover, and selection\&.
.PP
Differential Evolution is a stochastic, population-based optimizer that works well for non-linear,
non-differentiable, and multi-modal objective functions\&. It does not require gradient information and
is effective in high-dimensional or rugged search spaces\&. The user-supplied objective function should
take a vector of parameters as input and return a scalar value to be minimized\&. For example, the
objective function might compute the volume of material used in a structure given its geometric
parameters, the error rate of a machine learning model, or the energy of a physical system\&. DE begins
by initializing a population of random candidate solutions within given parameter bounds and
iteratively refines them by combining members of the population and selecting better solutions over
generations\&.
.PP
Simple constraints are placed on parameter values by adding objects of class \fI::tclopt::Parameter\fP to
DE with method \fI::tclopt::Optimization::addPars\fP\&. For details of how to specify constraints, please
look at the description of \fI::tclopt::Parameter\fP class\&. Please note, that order in which we attach
parameters objects is the order in which values will be supplied to minimized function, and the order
in which resulted will be written to x property of the class\&.
.PP
\fBGeneral advices\fR
.TP
\(bu
f is usually between 0\&.5 and 1 (in rare cases > 1)
.TP
\(bu
cr is between 0 and 1 with 0\&., 0\&.3, 0\&.7 and 1\&. being worth to be tried first
.TP
\(bu
To start off np = 10*d is a reasonable choice\&. Increase np if misconvergence happens\&.
.TP
\(bu
If you increase np, f usually has to be decreased
.TP
\(bu
When the DE/best\&.\&.\&. schemes fail DE/rand\&.\&.\&. usually works and vice versa
.PP
\fBStrategies overview\fR
.PP
Naming convention for strategies: x/y/z, where:
.TP
\(bu
x - a string which denotes the vector to be perturbed (mutated)
.TP
\(bu
y - number of difference vectors taken for perturbation (mutation) of x
.TP
\(bu
z - crossover method (exp = exponential, bin = binomial)
.PP
\fBMutation\fR
.PP
Combination of x and y gives following mutation function:
.PP
best/1:
.PP
.RS 4n
.nf
→    →         →     →
u  = x  + f ⋅ ⎛x   - x  ⎞
 i    b       ⎝ r2    r3⎠
.fi
.RE
.PP
rand/1:
.PP
.RS 4n
.nf
→    →         →     →
u  = x  + f ⋅ ⎛x   - x  ⎞
 i    r1      ⎝ r2    r3⎠
.fi
.RE
.PP
rand-to-best/1 (custom variant):
.PP
.RS 4n
.nf
→    →         →     →           →     →
u  = x  + f ⋅ ⎛x   - x  ⎞ + f ⋅ ⎛x   - x  ⎞
 i    i       ⎝ b     i ⎠       ⎝ r1    r2⎠
.fi
.RE
.PP
best/2:
.PP
.RS 4n
.nf
→    →         →     →     →     →
u  = x  + f ⋅ ⎛x   + x   - x   - x  ⎞
 i    b       ⎝ r1    r2    r3    r4⎠
.fi
.RE
.PP
rand/2:
.PP
.RS 4n
.nf
→    →         →     →     →     →
u  = x  + f ⋅ ⎛x   + x   - x   - x  ⎞
 i    r5      ⎝ r1    r2    r3    r4⎠
.fi
.RE
.PP
x_i - trial vector, x_b - best vector, x_rn - randomly selected individuals from population\&.
.PP
A crossover operation between the new generated mutant vector v_i and the target vector x_i is used to
further increase the diversity of the new candidate solution\&.
.PP
\fBExponential crossover\fR
.PP
In exponential crossover, a contiguous block of dimensions is modified, starting from a random index,
and continues as long as random values are less than CR\&. The mutation happens inline during crossover,
and wrapping around is supported\&.
.PP
.RS 4n
.nf
Example (D = 10, n = 3, L = 4):

Parent x_i:         [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9]
Exponential mask:             →  →  →  →
n  n+1 n+2 n+3

Trial u_i:          [x0 x1 x2 v3 v4 v5 v6 x7 x8 x9]
↑ mutated from DE strategy
.fi
.RE
.TP
\(bu
Starts from a random index n ∈ [0, D)
.TP
\(bu
Replaces a contiguous block of components (dimension-wise)
.TP
\(bu
Continues as long as rand() < CR, up to D components
.TP
\(bu
Mutation and crossover are applied together in the code, not as separate stages\&.
.PP
\fBBinomial crossover\fR
.PP
In binomial crossover, each dimension has an independent probability CR of being replaced by the mutant
vector\&. At least one dimension is guaranteed to be copied from the mutant (typically by forcing one
fixed index to be included)\&.
.PP
.RS 4n
.nf
Example (D = 10):

Parent x_i:         [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9]
Random mask:         ✗  ✓  ✗  ✗  ✓  ✗  ✓  ✗  ✗  ✓
Mutant values:      [v0 v1 v2 v3 v4 v5 v6 v7 v8 v9]

Trial u_i:          [x0 v1 x2 x3 v4 x5 v6 x7 x8 v9]
                         ↑       ↑       ↑     ↑
                    replaced where rand() < CR
.fi
.RE
.TP
\(bu
Applies independent crossover decision for each dimension
.TP
\(bu
Starts at a random dimension n, iterates D steps circularly
.TP
\(bu
Each dimension is replaced with probability CR
.TP
\(bu
Ensures at least one dimension is modified (usually last)
.TP
\(bu
Mutation and crossover are applied together in the code, not as separate stages\&.
.PP
\fBSummary of strategies\fR
.PP
.RS 4n
.nf
┌────┬──────────┬─────────────────────────────┬─────┬──────────────────────────────────┐
│ ID │  Base    │ Difference                  │ XOV │ Description                      │
├────┼──────────┼─────────────────────────────┼─────┼──────────────────────────────────┤
│ 1  │ best     │ r2 - r3                     │ exp │ Exploitative, may misconverge    │
│ 2  │ r1       │ r2 - r3                     │ exp │ Balanced, exploratory            │
│    │          │                             │     │ Try e\&.g\&. F=0\&.7 and CR=0\&.5 first  │
│ 3  │ x_i      │ (best - x_i) + (r1 - r2)    │ exp │ Hybrid: pull + variation         │
│    │          │                             │     │ Try e\&.g  F=0\&.85 and CR=1 first   │
│ 4  │ best     │ (r1 + r2) - (r3 + r4)       │ exp │ Exploratory, best-guided         │
│ 5  │ r5       │ (r1 + r2) - (r3 + r4)       │ exp │ Fully random, robust             │
│ 6  │ best     │ r2 - r3                     │ bin │ Same as 1, binomial crossover    │
│ 7  │ r1       │ r2 - r3                     │ bin │ Same as 2, binomial crossover    │
│ 8  │ x_i      │ (best - x_i) + (r1 - r2)    │ bin │ Same as 3, binomial crossover    │
│ 9  │ best     │ (r1 + r2) - (r3 + r4)       │ bin │ Same as 4, binomial crossover    │
│ 10 │ r5       │ (r1 + r2) - (r3 + r4)       │ bin │ Same as 5, binomial crossover    │
└────┴──────────┴─────────────────────────────┴─────┴──────────────────────────────────┘
.fi
.RE
.PP
See more information in \fItechreport\fP [URL: http://mirror\&.krakadikt\&.com/2004-11-13-genetic-algorithms/www\&.icsi\&.berkeley\&.edu/%257Estorn/deshort1\&.ps]
.PP
Description of keys and data in returned dictionary (not including history mode):
.RS 4n
.TP
objfunc
Final value of object (cost) function funct
.TP
x
Final vector of parameters\&.
.TP
generation
Number of generations\&.
.TP
strategy
Strategy used for optimization\&.
.TP
std
Standard deviation of final population\&.
.TP
debug
List of debug messages if -debug switch is provided\&.
.RE
.PP
You can also access result dictionary with [my configure -results]\&.
.PP
\fBHistory mode\fR
.PP
When the -history flag is provided, result also includes the following keys:
.PP
Key history - a dictionary with keys (one per -histfreq generation):
.RS 4n
.TP
gen
Generation index\&.
.TP
bestf
Best-so-far objective value after this generation\&.
.TP
mean
Mean objective value across the current population\&.
.TP
std
Standard deviation of objective values in the current population\&.
.TP
nfev
Cumulative number of function evaluations at the end of this generation\&.
.RE
.PP
Key besttraj - a dictionary with keys (one per -histfreq generation):
.RS 4n
.TP
gen
Generation index\&.
.TP
x
Parameter vector achieving the best-so-far objective value after this generation\&.
.RE
.PP
If the -savepop switch is provided as well, result additionally contains key pophistory with
dictionary with keys (one per -histfreq generation):
.RS 4n
.TP
gen
Generation index\&.
.TP
pop
List of population vectors for this generation (length = -np; each vector length = d)
.TP
cost
List of objective values aligned with pop (length = -np)
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
constructor
Constructor for the class\&.
.TP
[configure]
Configure properties\&. See \fI::oo::configuresupport::configurable\fP [URL: https://www\&.tcl-lang\&.org/man/tcl9\&.0/TclCmd/index\&.html]\&.
.TP
DuplChecker\&.duplListCheck
Inherited from \fIDuplChecker\fP\&.
.TP
Optimization\&.addPars
Inherited from \fIOptimization\fP\&.
.TP
Optimization\&.getAllPars
Inherited from \fIOptimization\fP\&.
.TP
Optimization\&.getAllParsNames
Inherited from \fIOptimization\fP\&.
.TP
run
Runs optimization\&.
.RE
.PP
\fBProperties\fR
.RS 4n
.TP
-abstol
Readable, writable\&. Absolute tolerance\&.
.TP
-cr
Readable, writable\&. Crossing over factor (crossover rate)\&.
.TP
-d
Readable, writable\&.
.TP
-debug
Readable, writable\&. Flag enabling printing of debug messages during optimization\&.
.TP
-f
Readable, writable\&. Weight factor (mutation rate)\&.
.TP
-funct
Readable, writable\&. Inherited\&.
.TP
-genmax
Readable, writable\&. Maximum number of generations\&.
.TP
-histfreq
Readable, writable\&. Period of history saving, saves each N iterations\&.
.TP
-history
Readable, writable\&. Flag enabling collecting scalar history and best trajectory\&.
.TP
-initpop
Readable, writable\&. Initial population\&.
.TP
-initype
Readable, writable\&.
.TP
-np
Readable, writable\&. Population size\&.
.TP
-pdata
Readable, writable\&.
.TP
-refresh
Readable, writable\&. Output refresh cycle\&.
.TP
-reltol
Readable, writable\&. Relative tolerance\&.
.TP
-results
Readable, writable\&. Inherited\&.
.TP
-savepop
Readable, writable\&. Flag enabling including population snapshots in history\&.
.TP
-seed
Readable, writable\&. Random seed\&.
.TP
-strategy
Readable, writable\&. Startegy used by the optimizer\&.
.TP
-threshold
Readable, writable\&. Objective function threshold that stops optimization\&.
.RE
.PP
\fBSuperclasses\fR
.PP
\fIOptimization\fP
.PP
.RS -4n
\fBconstructor\fR (::tclopt::DE)
.RE
.PP
Creates optimization object that runs optimization using modified Differential Evolution algorithm\&.
.RS 4n
\fBOBJECT constructor\fP \fI-funct value -strategy value -pdata value ?-genmax value? ?-refresh value? ?-np value? ?-f value? ?-cr value? ?-seed value? ?-abstol value? ?-reltol value? ?-debug? ?-random|specified -initpop value? ?-history? ?-histfreq value? ?-savepop?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-abstol value
Absolute tolerance\&. Controls termination of optimization\&. Default 1e-6\&.
.TP
-cr value
Crossing over factor (crossover rate)\&. Controls the probability of mixing components from the target vector and the mutant vector to form a trial vector\&. It determines how much of the trial vector inherits its components from the mutant vector versus the target vector\&. A high crossover rate means that more components will come from the mutant vector, promoting exploration of new solutions\&. Conversely, a low crossover rate results in more components being taken from the target vector, which can help maintain existing solutions and refine them\&. The typical range for CR is between 0\&.0 and 1\&.0\&. Default is 0\&.9\&.
.TP
-debug
Print debug messages during optimization\&.
.TP
-f value
Weight factor (mutation rate)\&. Controls the amplification of the differential variation between individuals\&. It is a scaling factor applied to the difference between two randomly selected population vectors before adding the result to a third vector to create a mutant vector (exact mechanism is dependent on selected strategy)\&. The mutation rate influences the algorithm's ability to explore the search space; a higher value of f increases the diversity of the mutant vectors, leading to broader exploration, while a lower value encourages convergence by making smaller adjustments\&. The typical range for f is between 0\&.4 and 1\&.0, though values outside this range can be used depending on the problem characteristics\&. Default is 0\&.9\&.
.TP
-funct value
Name of the procedure that should be minimized\&.
.TP
-genmax value
Maximum number of generations\&. Controls termination of optimization\&. Default 3000\&.
.TP
-histfreq value
Save history every N generations\&. Default is 1\&.
.TP
-history
Enables collecting scalar history and best trajectory\&.
.TP
-initpop value
List of lists (matrix) with size np x d, requires -specified\&.
.TP
-np value
Population size\&. Represents number of random parameter vector per generation\&. As a first guess for the value it is recommended to set it from 5 to 10 times the number of parameters\&. Default is 20\&.
.TP
-pdata value
List or dictionary that provides private data to funct that is needed to evaluate object (cost) function\&. Usually it contains x and y values lists, but you can provide any data necessary for function evaluation\&.  Will be passed upon each function evaluation without modification\&.
.TP
-random
Select population initialization with random values over the individual parameters ranges\&.
.TP
-refresh value
Output refresh cycle\&. Represent the frequency of printing debug information to stdout\&.
.TP
-reltol value
Relative tolerance\&. Controls termination of optimization\&. Default 1e-2\&.
.TP
-savepop
Enables including population snapshots in history (every -histfreq generations), requires -history\&.
.TP
-seed value
Random seed\&.
.TP
-specified
Select population initialization with specified population values, requires -initpop\&.
.TP
-strategy value
Choice of strategy\&. Possible strategies: best/1/exp rand/1/exp rand-to-best/1/exp best/2/exp rand/2/exp best/1/bin rand/1/bin rand-to-best/1/bin best/2/bin rand/2/bin\&.
.TP
-threshold value
Objective function threshold that stops optimization\&.
.RE
.PP
\fBReturn value\fR
.PP
object of class
.PP
.RS -4n
\fBrun\fR (::tclopt::DE)
.RE
.PP
Runs optimization\&.
.RS 4n
\fBDEOBJ run\fP
.br
.RE
.PP
\fBReturn value\fR
.PP
dictionary containing resulted data
.PP
.RS -4n
\fBDuplChecker\fR (::tclopt)
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
[configure]
Configure properties\&. See \fI::oo::configuresupport::configurable\fP [URL: https://www\&.tcl-lang\&.org/man/tcl9\&.0/TclCmd/index\&.html]\&.
.TP
duplListCheck
Checks if list contains duplicates\&.
.RE
.PP
\fBSubclasses\fR
.PP
\fIOptimization\fP
.PP
.RS -4n
\fBduplListCheck\fR (::tclopt::DuplChecker)
.RE
.PP
Checks if list contains duplicates\&.
.RS 4n
\fBDUPLCHECKEROBJ duplListCheck\fP \fIlist\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
list
List to check\&.
.RE
.PP
\fBReturn value\fR
.PP
0 if there are no duplicates and 1 if there are\&.
.PP
.RS -4n
\fBGSA\fR (::tclopt)
.RE
.PP
Class implements the Generalized Simulated Annealing (GSA) algorithm to solve global optimization
problems over continuous parameter spaces\&.
.PP
Generalized Simulated Annealing (GSA) is an enhanced version of the classical simulated annealing
algorithm, rooted in Tsallis statistics\&. It replaces traditional temperature schedules and perturbation
distributions with generalized forms: specifically, it uses a distorted Cauchy–Lorentz visiting
distribution controlled by a parameter qv, allowing for more flexible exploration of the solution
space\&. The algorithm introduces artificial “temperatures” that gradually cool, injecting stochasticity
to help the search process escape local minima and eventually converge within the basin of a global
minimum\&.
.PP
Main source of information is \fIthis article\fP [URL: https://journal\&.r-project\&.org/archive/2013/RJ-2013-002/RJ-2013-002\&.pdf]\&.
.PP
Simple constraints are placed on parameter values by adding objects of class \fI::tclopt::Parameter\fP to
GSA with method \fI::tclopt::Optimization::addPars\fP\&. For details of how to specify constraints, please
look at the description of \fI::tclopt::Parameter\fP class\&. Please note, that order in which we attach
parameters objects is the order in which values will be supplied to minimized function, and the order
in which resulted will be written to x property of the class\&.
.PP
\fBGeneral steps of algorithm\fR
.PP
\fB1\&. Inputs & setup\fR
.TP
\(bu
Provide: objective proc name, parameter objects, and algorithm controls parameters\&.
.TP
\(bu
Initialize RNG state
.PP
\fB2\&. Choose initial parameter vector x_0\fR
.TP
\(bu
If -specified, take each parameter’s -initval\&.
.TP
\(bu
If -random, sample uniformly within bounds: x_i = Unif\fIlow_i​, up_i\fP, i - i'th parameter
.PP
\fB3\&. Estimate initial temperature temp0 (if not provided)\fR
.TP
\(bu
Draw -ntrial random vectors uniformly within the box; evaluate objective at each\&.
.TP
\(bu
If -random, sample uniformly within bounds: x_i = Unif\fIlow_i​, up_i\fP, i - i'th parameter
.TP
\(bu
Let d be the number of parameters\&. Compute sample mean and std\&. dev\&. of objective values; set:
.PP
.RS 4n
.nf
temp  = stddev({f(x)})
    0
.fi
.RE
.PP
\fB4\&. Initialize loop state\fR
.TP
\(bu
Current point/value:
.PP
.RS 4n
.nf
 →       →   →      →  →
 x     = x , f    = f ⎛x ⎞
  curr    0   curr    ⎝ 0⎠
.fi
.RE
.TP
\(bu
Best-so-far within the current temperature: copy current to “best”\&.
.PP
\fB5\&. Outer loop over temperatures (cooling)\fR
.TP
\(bu
For outer iteration k=0,1,2,…, temperature is (Tsallis cooling):
.PP
.RS 4n
.nf
             ⎛ (qv - 1)    ⎞
     temp0 ⋅ ⎝2         - 1⎠
T  = ───────────────────────
 k            (qv - 1)
       (1 + t)         - 1
.fi
.RE
.PP
\fB6\&. Choose inner-iterations at this temperature\fR
.TP
\(bu
Inner iteration budget at T_k:
.PP
.RS 4n
.nf
         ⎛                ⎛                  ⎛         ⎛  -d  ⎞⎞⎞⎞
         ⎜                ⎜                  ⎜         ⎜──────⎟⎟⎟⎟
         ⎜                ⎜                  ⎜         ⎝3 - qv⎠⎟⎟⎟
n  = min ⎜maxinniter, max ⎜mininniter, floor ⎜nbase ⋅ T        ⎟⎟⎟
 t       ⎝                ⎝                  ⎝         k       ⎠⎠⎠
.fi
.RE
.PP
where d - number of parameters\&.
.PP
\fB7\&. Inner loop: propose, clamp, evaluate, accept\&. For t=1,\&.\&.\&., n_t:\fR
.TP
\(bu
Visit/perturb each coordinate (distorted Cauchy–Lorentz with qv)\&. Draw u~Unif(0,1)\&. If u>=0\&.5, sign=1, else sign=-1\&. Then step is:
.PP
.RS 4n
.nf
                               ____________________
                              ╱        (qv - 1)
             ⎛   1  ⎞        ╱ ⎛   1  ⎞
             ⎜──────⎟       ╱  ⎜──────⎟         - 1
             ⎝3 - qv⎠      ╱   ⎝|2u−1|⎠
Δx = sign ⋅ T         ⋅   ╱    ────────────────────
             k          ╲╱            qv - 1
.fi
.RE
.PP
Apply per coordinate, then clamp with modulo reflection into \fIlow, up\fP\&.
.TP
\(bu
Evaluate candidate and calculate the difference:
.PP
.RS 4n
.nf
   →               →
f ⎛x    ⎞; Δf = f ⎛x    ⎞ - f
  ⎝ cand⎠         ⎝ cand⎠    curr
.fi
.RE
.TP
\(bu
Acceptance rule (generalized qa-Metropolis): if Δf<=0 - accept, else accept with probability:
.PP
.RS 4n
.nf
If qa=1:
        ⎛-Δf ⋅ k⎞
p = exp ⎜───────⎟
        ⎜  T    ⎟
        ⎝   k   ⎠
If qa < 1:
            (1 - qa) ⋅ Δf ⋅ k
    z = 1 - ─────────────────
                   T
                    k

    If z<=0 then p=0, else:

         ⎛   1  ⎞
         ⎜──────⎟
         ⎝1 - qa⎠
    p = z

If qa > 1:
                           ⎛  -1  ⎞
                           ⎜──────⎟
                           ⎝qa - 1⎠
    ⎛    (qa - 1) ⋅ Δf ⋅ k⎞
p = ⎜1 + ─────────────────⎟
    ⎜           T         ⎟
    ⎝            k        ⎠
.fi
.RE
.PP
Accept with probability p\&.
.PP
\fB8\&. Best-of-temperature recentering\fR
.TP
\(bu
Track (x_best, f_best) during inner loop\&.
.TP
\(bu
After finishing n_k iterations, set:
.PP
.RS 4n
.nf
→       →
x     = x
 curr    best
→       →
f     = f
 curr    best
.fi
.RE
.TP
\(bu
Count attempted/accepted moves for diagnostics\&.
.PP
\fB9\&. Stopping conditions (checked each outer step)\fR
.TP
\(bu
If -threshold is set and best value lower or equal to threshold then stop\&.
.TP
\(bu
If k>=maxiter then stop\&.
.TP
\(bu
If T_k<=tmin then stop\&.
.TP
\(bu
If -maxfev is set and total function evals higher or equal to -maxfev then stop\&.
.PP
\fB10\&. Advance temperature or finish\fR
.TP
\(bu
If none of the stops triggered, increment k and repeat\&.
.TP
\(bu
On exit, return: best objective, best x, total evals, temp0, last temp_q (final T_k​), and a human-readable info message\&.
.PP
Description of keys and data in returned dictionary (not including history mode):
.RS 4n
.TP
objfunc
Final value of object (cost) function funct
.TP
x
Final vector of parameters\&.
.TP
nfev
Number of function evalutions\&.
.TP
temp0
Initial temperature\&.
.TP
tempend
End temperature\&.
.TP
info
Convergence information\&.
.TP
niter
Number of temperature iterations\&.
.RE
.PP
\fBHistory mode\fR
.PP
When the -history flag is provided, result also includes the following keys:
.PP
Key history - a dictionary with keys (one per -histfreq temperature and after the last iteration):
.RS 4n
.TP
iter
Temperature iteration index\&.
.TP
temp
Current temperature value\&.
.TP
bestf
Best-so-far (global best) objective value after this iteration\&.
.TP
currf
Current objective value\&.
.TP
nt
Number of iterations within current iteration (temperature)
.TP
accratio
Acceptance ratio in current iteration (temperature)
.TP
nfev
Cumulative number of function evaluations at the end of this iteration\&.
.RE
.PP
Key besttraj - a dictionary with keys (one per -histfreq temperature and after the last iteration):
.RS 4n
.TP
iter
Temperature iteration index\&.
.TP
x
Parameter vector achieving the best-so-far (global best) objective value after this iteration\&.
.RE
.PP
If the -savemoves switch is provided as well, result additionally contains key histmoves with
dictionary with keys (one per -histfreq temperature and after the last iteration):
.RS 4n
.TP
iter
Temperature iteration index\&.
.TP
moves
List of dictionaries that contains accepted moves in this temperature\&.
.RE
.PP
Each move in the list of moves is a dictionary with keys:
.RS 4n
.TP
tstep
Index of step inside of current temperature iteration\&.
.TP
x
Accepted parameter vector\&.
.TP
fx
Value of objective function for that accepted parameter vector\&.
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
constructor
Constructor for the class\&.
.TP
[configure]
Configure properties\&. See \fI::oo::configuresupport::configurable\fP [URL: https://www\&.tcl-lang\&.org/man/tcl9\&.0/TclCmd/index\&.html]\&.
.TP
DuplChecker\&.duplListCheck
Inherited from \fIDuplChecker\fP\&.
.TP
Optimization\&.addPars
Inherited from \fIOptimization\fP\&.
.TP
Optimization\&.getAllPars
Inherited from \fIOptimization\fP\&.
.TP
Optimization\&.getAllParsNames
Inherited from \fIOptimization\fP\&.
.TP
run
Runs optimization\&.
.RE
.PP
\fBProperties\fR
.RS 4n
.TP
-debug
Readable, writable\&. Flag enabling debug information printing\&.
.TP
-funct
Readable, writable\&. Inherited\&.
.TP
-histfreq
Readable, writable\&. Period of history saving, saves each N iterations\&.
.TP
-history
Readable, writable\&. Flag enabling collecting scalar history and best trajectory\&.
.TP
-initype
Readable, writable\&.
.TP
-maxfev
Readable, writable\&. Maximum number of objective function evaluation\&.
.TP
-maxinniter
Readable, writable\&. Maximum number of iterations per temperature\&.
.TP
-maxiter
Readable, writable\&. Maximum number of temperature steps\&.
.TP
-mininniter
Readable, writable\&. Minimum number of iterations per temperature\&.
.TP
-nbase
Readable, writable\&. Base number of iterations within single temperature\&.
.TP
-ntrial
Readable, writable\&. Initial number of samples to determine initial temperature temp0 (if not provided)\&.
.TP
-pdata
Readable, writable\&.
.TP
-qa
Readable, writable\&. Acceptance distribution parameter\&.
.TP
-qv
Readable, writable\&. Visiting distribution parameter\&.
.TP
-refresh
Readable, writable\&. Output refresh cycle\&.
.TP
-results
Readable, writable\&. Inherited\&.
.TP
-savemoves
Readable, writable\&. Flag enabling including accepted moves snapshots in history\&.
.TP
-seed
Readable, writable\&. Random seed\&.
.TP
-temp0
Readable, writable\&. Initial temperature value\&.
.TP
-threshold
Readable, writable\&. Define stopping value - stop when best objective function value is lower than this threshold\&.
.TP
-tmin
Readable, writable\&. Define stopping value - stop when temperature is lower than this value\&.
.RE
.PP
\fBSuperclasses\fR
.PP
\fIOptimization\fP
.PP
.RS -4n
\fBconstructor\fR (::tclopt::GSA)
.RE
.PP
Creates optimization object that tuns optimization using modified Gegeneralized Simulation Annealing
algorithm\&.
.RS 4n
\fBOBJECT constructor\fP \fI-funct value -pdata value ?-maxiter value? ?-mininniter value? ?-maxfev value? ?-seed value? ?-ntrial value? ?-nbase value? ?-qv value? ?-qa value? ?-tmin value? ?-temp0 value? ?-debug? ?-threshold value? ?-random|specified -initpop value? ?-history? ?-histfreq value? ?-savemoves?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-debug
Enables debug information printing\&.
.TP
-funct value
Name of the procedure that should be minimized\&.
.TP
-histfreq value
Save history every N generations\&. Default is 1\&.
.TP
-history
Enables collecting scalar history and best trajectory\&.
.TP
-maxfev value
Maximum number of objective function evaluation\&. Controls termination of optimization if provided\&.
.TP
-maxinniter value
Maximum number of iterations per temperature, default is 1000\&.
.TP
-maxiter value
Maximum number of temperature steps\&. Controls termination of optimization\&. Default is 5000\&.
.TP
-mininniter value
Minimum number of iterations per temperature, default is 10\&.
.TP
-nbase value
Base number of iterations within single temperature, default is 30\&.
.TP
-ntrial value
Initial number of samples to determine initial temperature temp0 (if not provided), default is 20\&.
.TP
-pdata value
List or dictionary that provides private data to funct that is needed to evaluate object (cost) function\&. Usually it contains x and y values lists, but you can provide any data necessary for function evaluation\&.  Will be passed upon each function evaluation without modification\&.
.TP
-qa value
Acceptance distribution parameter (qa ≠ 1, can be negative)\&. Default -5\&.0\&.
.TP
-qv value
Visiting distribution parameter, must satisfy 1 < qv < 3\&. Default 2\&.62\&.
.TP
-random
Random parameter vector initialization\&.
.TP
-refresh value
Output refresh cycle\&. Represent the frequency of printing debug information to stdout\&.
.TP
-savemoves
Enables including accepted moves snapshots in history (every -histfreq generations), requires -history\&.
.TP
-seed value
Random seed, default is 0\&.
.TP
-specified
Specified points parameter vector initialization\&.
.TP
-temp0 value
Initial temperature value; if not given, estimated from ntrial samples\&.
.TP
-threshold value
Stop when best objective ≤ threshold (optional)\&.
.TP
-tmin value
Stop when temperature ≤ tmin\&. Default 1e-5\&.
.RE
.PP
\fBReturn value\fR
.PP
object of class
.PP
.RS -4n
\fBrun\fR (::tclopt::GSA)
.RE
.PP
Runs optimization\&.
.RS 4n
\fBGSAOBJ run\fP
.br
.RE
.PP
\fBReturn value\fR
.PP
dictionary containing resulted data
.PP
.RS -4n
\fBLBFGS\fR (::tclopt)
.RE
.PP
Class represents optimization object that runs optimization using modified Limited-memory
Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) method written by Jorge Nocedal\&.
.PP
\fBMethod summary\fR
.RS 4n
.TP
constructor
Constructor for the class\&.
.TP
[configure]
Configure properties\&. See \fI::oo::configuresupport::configurable\fP [URL: https://www\&.tcl-lang\&.org/man/tcl9\&.0/TclCmd/index\&.html]\&.
.TP
DuplChecker\&.duplListCheck
Inherited from \fIDuplChecker\fP\&.
.TP
Optimization\&.addPars
Inherited from \fIOptimization\fP\&.
.TP
Optimization\&.getAllPars
Inherited from \fIOptimization\fP\&.
.TP
Optimization\&.getAllParsNames
Inherited from \fIOptimization\fP\&.
.TP
run
Runs optimization\&.
.RE
.PP
\fBProperties\fR
.RS 4n
.TP
-condition
Readable, writable\&. Condition type to satisfy in backtracking algorithm\&.
.TP
-delta
Readable, writable\&. Delta for convergence test\&.
.TP
-dstepmin
Readable, writable\&. Minimum absolute step for finite differences\&.
.TP
-dstepscale
Readable, writable\&. Multiplier for finite-difference step size\&.
.TP
-epsilon
Readable, writable\&. Epsilon for convergence test\&.
.TP
-ftol
Readable, writable\&. A parameter to control the accuracy of the linesearch routine\&.
.TP
-funct
Readable, writable\&. Inherited\&.
.TP
-gradient
Readable, writable\&. Type of gradient calculation algorithm\&.
.TP
-gtol
Readable, writable\&. A parameter to control the accuracy of the linesearch routine\&.
.TP
-histfreq
Readable, writable\&. Period of history saving, saves each N iterations\&.
.TP
-history
Readable, writable\&. Flag enabling collecting scalar history\&.
.TP
-linesearch
Readable, writable\&. The linesearch algorithm\&.
.TP
-m
Readable, writable\&.
.TP
-maxiter
Readable, writable\&. The maximum number of iterations\&.
.TP
-maxlinesearch
Readable, writable\&. The maximum number of trials for the linesearch\&.
.TP
-maxstep
Readable, writable\&. The maximum step of the linesearch routine\&.
.TP
-minstep
Readable, writable\&. The minimum step of the linesearch routine\&.
.TP
-orthantwisec
Readable, writable\&. Coefficient for the L1 norm of variables\&.
.TP
-orthantwiseend
Readable, writable\&. End index for computing L1 norm of the variables\&.
.TP
-orthantwisestart
Readable, writable\&. Start index for computing L1 norm of the variables\&.
.TP
-past
Readable, writable\&. Distance for delta-based convergence test\&.
.TP
-pdata
Readable, writable\&.
.TP
-results
Readable, writable\&. Inherited\&.
.TP
-wolfe
Readable, writable\&. A coefficient for the Wolfe condition\&.
.TP
-xtol
Readable, writable\&. The machine precision for floating-point values\&.
.RE
.PP
\fBSuperclasses\fR
.PP
\fIOptimization\fP
.PP
.RS -4n
\fBconstructor\fR (::tclopt::LBFGS)
.RE
.PP
Creates optimization object that runs optimization using modified Limited-memory
Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) method written by Jorge Nocedal\&.
.RS 4n
\fBOBJECT constructor\fP \fI-funct value -pdata value ?-gradient value? ?-dstepmin value? ?-dstepscale value? ?-epsilon value? ?-past value? ?-delta value? ?-maxiter value? ?-linesearch value? ?-maxlinesearch value? ?-minstep value? ?-maxstep value? ?-ftol value? ?-wolfe value? ?-gtol value? ?-xtol value? ?-condition value? ?-orthantwisec value ?-orthantwisestart value? ?-orthantwiseend value?? ?-history? ?-histfreq value?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-condition
Condition type to satisfy in backtracking algorithm, default is wolfe, availiable values: armijo, wolfe, strongwolfe\&.
.TP
-delta
Delta for convergence test, default is 1e-5\&.
.TP
-dstepmin
Minimum absolute step for finite differences, default is 1e-12\&.
.TP
-dstepscale
Multiplier for finite-difference step size, default is 1\&.0\&.
.TP
-epsilon
Epsilon for convergence test, default is 1e-5\&.
.TP
-ftol
A parameter to control the accuracy of the linesearch routine, default is 1e-4\&.
.TP
-funct value
Name of the procedure that should be minimized\&.
.TP
-gradient value
Type of gradient calculation algorithm\&. Possible values: analytic - objective funcion provides gradient itself, forward - numerical forward difference, central - numerical central difference\&. Default is analytic\&.
.TP
-gtol
A parameter to control the accuracy of the linesearch routine, default is 0\&.9\&.
.TP
-histfreq
Save history every N iterations, default is 1\&.
.TP
-history
Collect scalar history\&.
.TP
-linesearch
The linesearch algorithm, default is morethuente, possible values: morethuente and backtracking\&.
.TP
-m value
The number of corrections to approximate the inverse hessian matrix, default is 6\&.
.TP
-maxiter
The maximum number of iterations, use for convergence if value provided\&.
.TP
-maxlinesearch
The maximum number of trials for the linesearch routine, default is 40\&.
.TP
-maxstep
The maximum step of the linesearch routine, default is 1e20\&.
.TP
-minstep
The minimum step of the linesearch routine, default is 1e-20\&.
.TP
-orthantwisec
Coefficient for the L1 norm of variables, providing value enables Orthant-Wise Limited-memory Quasi-Newton (OWL-QN) method\&. Allows only backtracking -linesearch algorithm\&.
.TP
-orthantwiseend
End index for computing L1 norm of the variables, requires -orthantwisec\&.
.TP
-orthantwisestart
Start index for computing L1 norm of the variables, requires -orthantwisec\&.
.TP
-past
Distance for delta-based convergence test, default is 0\&.
.TP
-pdata value
List or dictionary that provides private data to funct that is needed to evaluate object (cost) function\&. Usually it contains x and y values lists, but you can provide any data necessary for function evaluation\&.  Will be passed upon each function evaluation without modification\&.
.TP
-wolfe
A coefficient for the Wolfe condition, default is 0\&.9, value must be withhin [ftol, 1\&.0)
.TP
-xtol
The machine precision for floating-point values, default is 1e-16\&.
.RE
.PP
\fBReturn value\fR
.PP
object of class
.PP
.RS -4n
\fBrun\fR (::tclopt::LBFGS)
.RE
.PP
Runs optimization\&.
.RS 4n
\fBLBFGSOBJ run\fP
.br
.RE
.PP
\fBReturn value\fR
.PP
dictionary containing resulted data
.PP
.RS -4n
\fBMpfit\fR (::tclopt)
.RE
.PP
Class represents Levenberg-Marquardt optimizator - least-square optimization algorithm\&.
Class uses the Levenberg-Marquardt technique to solve the least-squares problem\&. In its typical use, it
will be used to fit a user-supplied function (the "model") to user-supplied data points (the "data") by
adjusting a set of parameters\&. mpfit is based upon MINPACK-1 (LMDIF\&.F) by More' and collaborators\&.
The user-supplied function should compute an array of weighted deviations between model and data\&. In a
typical scientific problem the residuals should be weighted so that each deviate has a gaussian sigma
of 1\&.0\&. If x represents values of the independent variable, y represents a measurement for each value
of x, and err represents the error in the measurements, then the deviates could be calculated as
follows:
.PP
.RS 4n
.nf
for {set i 0} {$i<$m} {incr i} {
    lset deviates $i [expr {([lindex $y $i] - [f [lindex $x $i]])/[lindex $err $i]}]
}
.fi
.RE
.PP
where m is the number of data points, and where f is the function representing the model evaluated at
x\&. If ERR are the 1-sigma uncertainties in Y, then the sum of deviates squared will be the total
chi-squared value, which mpfit will seek to minimize\&.
Simple constraints are placed on parameter values by adding objects of class \fI::tclopt::ParameterMpfit\fP
to mpfit with method \fI::tclopt::Optimization::addPars\fP, where other parameter-specific options can be
set\&.  For details of how to specify constraints, please look at the description of
\fI::tclopt::ParameterMpfit\fP class\&. Please note, that order in which we attach parameters objects is the
order in which values will be supplied to minimized function, and the order in which resulted will be
written to X property of the class\&.
Example of user defined function (using linear equation t=a+b*x):
.PP
.RS 4n
.nf
proc f {xall pdata args} {
    set x [dget $pdata x]
    set y [dget $pdata y]
    set ey [dget $pdata ey]
    foreach xVal $x yVal $y eyVal $ey {
        set f [= {[@ $xall 0]+[@ $xall 1]*$xVal}]
        lappend fval [= {($yVal-$f)/$eyVal}]
    }
    return [dcreate fvec $fval]
}
.fi
.RE
.PP
where xall is list of initial parameters values, pdata - dictionary that contains x, y and ey lists with
length m\&. It returns dictionary with residuals values\&.
Alternative form of function f could also provide analytical derivatives:
.PP
.RS 4n
.nf
proc quadfunc {xall pdata args} {
    set x [dget $pdata x]
    set y [dget $pdata y]
    set ey [dget $pdata ey]
    foreach xVal $x yVal $y eyVal $ey {
        lappend fvec [= {($yVal-[@ $xall 0]-[@ $xall 1]*$xVal-[@ $xall 2]*$xVal*$xVal)/$eyVal}]
    }
    if {[@ $args 0]!=""} {
        set derivs [@ $args 0]
        foreach deriv $derivs {
            if {$deriv==0} {
                foreach xVal $x yVal $y eyVal $ey {
                    lappend dvec [= {-1/$eyVal}]
                }
            }
            if {$deriv==1} {
                foreach xVal $x yVal $y eyVal $ey {
                    lappend dvec [= {(-$xVal)/$eyVal}]
                }
            }
            if {$deriv==2} {
                foreach xVal $x yVal $y eyVal $ey {
                    lappend dvec [= {(-$xVal*$xVal)/$eyVal}]
                }
            }
        }
        return [dcreate fvec $fvec dvec $dvec]
    } else {
        return [dcreate fvec $fvec]
    }
}
.fi
.RE
.PP
The first element of the args list is a list specifying the ordinal numbers of the parameters for
which we need to calculate the analytical derivative\&. In this case, the returned dvec list contains
the derivative at each x point for each specified parameter, following the same order as in the input
list\&. For example, if the input list is {0, 2} and the number m of x points is 3, the dvec list will
look like this:
.PP
.RS 4n
.nf
⎛⎛df ⎞   ⎛df ⎞   ⎛df ⎞   ⎛df ⎞   ⎛df ⎞   ⎛df ⎞  ⎞
⎜⎜───⎟   ⎜───⎟   ⎜───⎟   ⎜───⎟   ⎜───⎟   ⎜───⎟  ⎟
⎜⎝dp0⎠   ⎝dp0⎠   ⎝dp0⎠   ⎝dp2⎠   ⎝dp2⎠   ⎝dp2⎠  ⎟
⎝     x0      x1      x2      x0      x1      x2⎠
.fi
.RE
.PP
Description of keys and data in returned dictionary:
.RS 4n
.TP
bestnorm
Final chi^2\&.
.TP
orignorm
Starting value of chi^2\&.
.TP
status
Fitting status code\&.
.TP
niter
Number of iterations\&.
.TP
nfev
Number of function evaluations\&.
.TP
npar
Total number of parameters\&.
.TP
nfree
Number of free parameters\&.
.TP
npegged
Number of pegged parameters\&.
.TP
nfunc
Number of residuals (= num\&. of data points)
.TP
resid
List of final residuals\&.
.TP
xerror
Final parameter uncertainties (1-sigma), in the order of elements in Pars property dictionary\&.
.TP
x
Final parameters values list in the order of elements in Pars property dictionary\&.
.TP
debug
String with derivatives debugging output, and general debug messages if switch -debug is provided\&.
.TP
covar
Final parameters covariance matrix\&. You can also access result dictionary with [my configure -results]\&.
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
constructor
Constructor for the class\&.
.TP
[configure]
Configure properties\&. See \fI::oo::configuresupport::configurable\fP [URL: https://www\&.tcl-lang\&.org/man/tcl9\&.0/TclCmd/index\&.html]\&.
.TP
DuplChecker\&.duplListCheck
Inherited from \fIDuplChecker\fP\&.
.TP
Optimization\&.addPars
Inherited from \fIOptimization\fP\&.
.TP
Optimization\&.getAllPars
Inherited from \fIOptimization\fP\&.
.TP
Optimization\&.getAllParsNames
Inherited from \fIOptimization\fP\&.
.TP
run
Runs optimization\&.
.RE
.PP
\fBProperties\fR
.RS 4n
.TP
-covtol
Readable, writable\&. Maximum number of iterations\&.
.TP
-debug
Readable, writable\&. Flag enabling printing of debug messages during optimization into stdout\&.
.TP
-epsfcn
Readable, writable\&. Finite derivative step size\&.
.TP
-ftol
Readable, writable\&. Algorithm terminating value, measures the relative error desired in the sum of squares\&.
.TP
-funct
Readable, writable\&. Inherited\&.
.TP
-gtol
Readable, writable\&. Algorithm terminating value, measures measures the orthogonality desired between the function vector and the columns of the Jacobian\&.
.TP
-histfreq
Readable, writable\&. Period of history saving, saves each N iterations\&.
.TP
-history
Readable, writable\&. Flag enabling collecting scalar history\&.
.TP
-m
Readable, writable\&. Number of data points\&.
.TP
-maxfev
Readable, writable\&. Algorithm terminating value, represents the maximum number of objective function evaluation\&.
.TP
-maxiter
Readable, writable\&.
.TP
-nofinitecheck
Readable, writable\&. Flag enabling check for infinite quantities\&.
.TP
-pdata
Readable, writable\&.
.TP
-refresh
Readable, writable\&. Output refresh cycle\&.
.TP
-results
Readable, writable\&. Inherited\&.
.TP
-stepfactor
Readable, writable\&. Value determining the initial step bound\&.
.TP
-xtol
Readable, writable\&. Algorithm terminating value, measures the relative error desired in the approximate solution\&.
.RE
.PP
\fBSuperclasses\fR
.PP
\fIOptimization\fP
.PP
.RS -4n
\fBconstructor\fR (::tclopt::Mpfit)
.RE
.PP
Creates optimization object that does least squares fitting using modified Levenberg-Marquardt algorithm\&.
.RS 4n
\fBOBJECT constructor\fP \fI-funct value -m value -pdata value ?-ftol value? ?-xtol value? ?-gtol value? ?-stepfactor value? ?-covtol value? ?-maxiter value? ?-maxfev value? ?-epsfcn value? ?-nofinitecheck? ?-refresh value? ?-debug? ?-history? ?-histfreq value?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-covtol value
Range tolerance for covariance calculation\&. Value must be of the type float more than zero, default is 1e-14\&.
.TP
-debug
Print debug messages during optimization\&.
.TP
-epsfcn value
Finite derivative step size\&. Value must be of the type float more than zero, default is 2\&.2204460e-16\&.
.TP
-ftol value
Control termination of mpfit\&. Termination occurs when both the actual and predicted relative reductions in the sum of squares are at most ftol\&. Therefore, ftol measures the relative error desired in the sum of squares\&. Value must be of the type float more than zero, default is 1e-10\&.
.TP
-funct value
Name of the procedure that should be minimized\&.
.TP
-gtol value
Control termination of mpfit\&. Termination occurs when the cosine of the angle between fvec and any column of the jacobian is at most gtol in absolute value\&. Therefore, gtol measures the orthogonality desired between the function vector and the columns of the jacobian\&. Value must be of the type float more than zero, default is 1e-10\&.
.TP
-histfreq
Save history every N iterations, default is 1\&.
.TP
-history
Collect scalar history\&.
.TP
-m value
Number of data points\&.
.TP
-maxfev value
Control termination of mpfit\&. Termination occurs when the number of calls to funct is at least maxfev by the end of an iteration\&. Value must be the positive integer, default is 0\&. If it equals to 0, number of evaluations is not restricted\&.
.TP
-maxiter value
Maximum number of iterations\&. If maxiter equal to 0, then basic error checking is done, and parameter errors/covariances are estimated based on input arameter values, but no fitting iterations are done\&. Value must be the positive integer, default is 200\&.
.TP
-nofinitecheck
Enables check for infinite quantities, default is off\&.
.TP
-pdata value
List or dictionary that provides private data to funct that is needed to evaluate residuals\&. Usually it contains x and y values lists, but you can provide any data necessary for function residuals evaluation\&.  Will be passed upon each function evaluation without modification\&.
.TP
-refresh value
Output refresh cycle\&. Represent the frequency of printing debug information to stdout\&.
.TP
-stepfactor value
Used in determining the initial step bound\&. This bound is set to the product of factor and the euclidean norm of diag*x if nonzero, or else to factor itself\&. In most cases factor should lie in the interval (\&.1,100\&.)\&. 100\&. is a generally recommended value\&. Value must be of the type float more than zero, default is 100\&.
.TP
-xtol value
Control termination of mpfit\&. Termination occurs when the relative error between two consecutive iterates is at most xtol\&. Therefore, xtol measures the relative error desired in the approximate solution\&.  Value must be of the type float more than zero, default is 1e-10\&.
.RE
.PP
\fBReturn value\fR
.PP
object of class
.PP
.RS -4n
\fBrun\fR (::tclopt::Mpfit)
.RE
.PP
Runs optimization\&.
.RS 4n
\fBMPFITOBJ run\fP
.br
.RE
.PP
\fBReturn value\fR
.PP
dictionary containing resulted data
.PP
.RS -4n
\fBOptimization\fR (::tclopt)
.RE
.PP
Class is the abstract class representing any optimizer of the package\&.
.PP
\fBMethod summary\fR
.RS 4n
.TP
[configure]
Configure properties\&. See \fI::oo::configuresupport::configurable\fP [URL: https://www\&.tcl-lang\&.org/man/tcl9\&.0/TclCmd/index\&.html]\&.
.TP
addPars
Not documented\&.
.TP
DuplChecker\&.duplListCheck
Inherited from \fIDuplChecker\fP\&.
.TP
getAllPars
Gets references of all parameters objects\&.
.TP
getAllParsNames
Gets names of all parameters\&.
.RE
.PP
\fBProperties\fR
.RS 4n
.TP
-funct
Readable, writable\&. Name of the cost (objective) function called by the optimizer\&.
.TP
-pdata
Readable, writable\&. Data that is passed to cost function with auxilary data needed for its evaluation\&.
.TP
-results
Readable, writable\&. Contains dictionary with the results of optimization\&.
.RE
.PP
\fBMixins\fR
.PP
\fIDuplChecker\fP
.PP
\fBSubclasses\fR
.PP
\fIMpfit\fP, \fIDE\fP, \fIGSA\fP, \fILBFGS\fP
.PP
.RS -4n
\fBaddPars\fR (::tclopt::Optimization)
.RE
.RS 4n
\fBOPTIMIZATIONOBJ addPars\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
.RS -4n
\fBgetAllPars\fR (::tclopt::Optimization)
.RE
.PP
Gets references of all parameters objects\&.
.RS 4n
\fBOPTIMIZATIONOBJ getAllPars\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
\fBReturn value\fR
.PP
list of elements names
.PP
.RS -4n
\fBgetAllParsNames\fR (::tclopt::Optimization)
.RE
.PP
Gets names of all parameters\&.
.RS 4n
\fBOPTIMIZATIONOBJ getAllParsNames\fP \fI?args?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.RE
.PP
\fBReturn value\fR
.PP
list of elements names
.PP
.RS -4n
\fBParameter\fR (::tclopt)
.RE
.PP
Class represents basic parameter of optimization\&.
.PP
Example of building 4 parameters with different constraints:
.PP
.RS 4n
.nf
set par0 [::tclopt::Parameter new a 1\&.0 -lowlim 0\&.0]
set par1 [::tclopt::Parameter new b 2\&.0]
set par2 [::tclopt::Parameter new c 0\&.0]
set par3 [::tclopt::Parameter new d 0\&.1 -lowlim -0\&.3 -uplim 0\&.2]
.fi
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
constructor
Constructor for the class\&.
.TP
[configure]
Configure properties\&. See \fI::oo::configuresupport::configurable\fP [URL: https://www\&.tcl-lang\&.org/man/tcl9\&.0/TclCmd/index\&.html]\&.
.RE
.PP
\fBProperties\fR
.RS 4n
.TP
-initval
Readable, writable\&. Initial value of the parameter\&.
.TP
-lowlim
Readable, writable\&. Lower limit of the parameter\&.
.TP
-name
Readable, writable\&. Name of the parameter\&.
.TP
-uplim
Readable, writable\&. Upper limit of the parameter\&.
.RE
.PP
\fBSubclasses\fR
.PP
\fIParameterMpfit\fP
.PP
.RS -4n
\fBconstructor\fR (::tclopt::Parameter)
.RE
.PP
Creates parameter object\&.
.RS 4n
\fBOBJECT constructor\fP \fIvalue value ?-fixed? ?-lowlim value? ?-uplim value? ?-step value? ?-relstep value? ?-side value? ?-debugder -debugreltol value -debugabstol value?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-lowlim value
Specify lower limit for parameter, must be lower than upper limit if upper limit is provided, optional\&.
.TP
-uplim value
Specify upper limit for parameter, must be higher than lower limit if lower limit is provided, optional\&.
.TP
initval
Initial value of parameter\&.
.TP
name
Name of the parameter\&.
.RE
.PP
.RS -4n
\fBParameterMpfit\fR (::tclopt)
.RE
.PP
Class represents basic parameter used by optimizator class \fI::tclopt::Mpfit\fP\&.
.PP
Example of building 4 parameters with different constraints:
.PP
.RS 4n
.nf
set par0 [ParameterMpfit new a 1\&.0 -fixed -side both]
set par1 [ParameterMpfit new b 2\&.0]
set par2 [ParameterMpfit new c 0\&.0 -fixed]
set par3 [ParameterMpfit new d 0\&.1 -lowlim -0\&.3 -uplim 0\&.2]
.fi
.RE
.PP
\fBMethod summary\fR
.RS 4n
.TP
constructor
Constructor for the class\&.
.TP
[configure]
Configure properties\&. See \fI::oo::configuresupport::configurable\fP [URL: https://www\&.tcl-lang\&.org/man/tcl9\&.0/TclCmd/index\&.html]\&.
.RE
.PP
\fBProperties\fR
.RS 4n
.TP
-debugder
Readable, writable\&. Flag enabling console debug logging of user-computed derivatives\&.
.TP
-derivabstol
Readable, writable\&.
.TP
-derivreltol
Readable, writable\&.
.TP
-fixed
Readable, writable\&. Flag for fixing parameter value during the optimization\&.
.TP
-initval
Readable, writable\&. Inherited\&.
.TP
-lowlim
Readable, writable\&. Inherited\&.
.TP
-name
Readable, writable\&. Inherited\&.
.TP
-relstep
Readable, writable\&. The relative step size to be used in calculating the numerical derivatives\&.
.TP
-side
Readable, writable\&. The sidedness of the finite difference when computing numerical derivatives\&.
.TP
-step
Readable, writable\&. The step size to be used in calculating the numerical derivatives\&.
.TP
-uplim
Readable, writable\&. Inherited\&.
.RE
.PP
\fBSuperclasses\fR
.PP
\fIParameter\fP
.PP
.RS -4n
\fBconstructor\fR (::tclopt::ParameterMpfit)
.RE
.PP
Creates parameter object for \fI::tclopt::Mpfit\fP class\&.
.RS 4n
\fBOBJECT constructor\fP \fIvalue value ?-fixed? ?-lowlim value? ?-uplim value? ?-step value? ?-relstep value? ?-side value? ?-debugder -debugreltol value -debugabstol value?\fP
.br
.RE
.PP
\fBParameters\fR
.RS 4n
.TP
-debugabstol value
Absolute error that controls printing of derivatives comparison if absolute error exceeds this value\&. Requires -debugder and -debugreltol\&.
.TP
-debugder
Switch to enable console debug logging of user-computed derivatives, as described above\&. Note that when debugging is enabled, then -side should be set to auto, right, left or both, depending on which numerical derivative you wish to compare to\&. Requires -debugreltol and -debugabstol values\&.
.TP
-debugreltol value
Relative error that controls printing of derivatives comparison if relative error exceeds this value\&. Requires -debugder and -debugabstol\&.
.TP
-fixed
Specify that parameter is fixed during optimization, optional\&.
.TP
-lowlim value
Specify lower limit for parameter, must be lower than upper limit if upper limit is provided, optional\&.
.TP
-relstep value
The relative step size to be used in calculating the numerical derivatives\&. This number is the fractional size of the step, compared to the parameter value\&. This value supercedes the -step setting\&. If the parameter is zero, then a default step size is chosen\&.
.TP
-side value
The sidedness of the finite difference when computing numerical derivatives\&. This field can take four values: auto : one-sided derivative computed automatically, right : one-sided derivative (f(x+h)-f(x))/h, left : one-sided derivative (f(x)-f(x-h))/h, both : two-sided derivative (f(x+h)-f(x-h))/(2*h), an : user-computed explicit derivatives, where h is the -step parameter described above\&. The "automatic" one-sided derivative method will chose a direction for the finite difference which does not violate any constraints\&. The other methods do not perform this check\&. The two-sided method is in principle more precise, but requires twice as many function evaluations\&. Default is auto\&.
.TP
-step value
The step size to be used in calculating the numerical derivatives\&.  If set to zero, then the step size is computed automatically, optional\&.
.TP
-uplim value
Specify upper limit for parameter, must be higher than lower limit if lower limit is provided, optional\&.
.TP
initval
Initial value of parameter\&.
.TP
name
Name of the parameter\&.
.RE

